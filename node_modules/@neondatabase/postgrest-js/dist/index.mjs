import { PostgrestClient } from "@supabase/postgrest-js";

//#region src/client/postgrest-client.ts
/**
* Neon PostgreSQL client for querying the Neon Data API
*
* This is a generic PostgreSQL client without authentication built-in.
* For auth-integrated clients, use @neondatabase/neon-js instead.
*
* Extends the upstream PostgrestClient with Neon-specific configuration.
*/
var NeonPostgrestClient = class extends PostgrestClient {
	constructor({ dataApiUrl, options }) {
		super(dataApiUrl, {
			headers: options?.global?.headers,
			fetch: options?.global?.fetch,
			schema: options?.db?.schema
		});
	}
};

//#endregion
//#region package.json
var name = "@neondatabase/postgrest-js";
var version = "0.1.0-alpha.1";

//#endregion
//#region ../internal/dist/index.mjs
const X_NEON_CLIENT_INFO_HEADER = "X-Neon-Client-Info";
/**
* Type guard for checking if a property exists on globalThis
*/
function hasGlobalProperty(key) {
	return key in globalThis;
}
/**
* Detects the JavaScript framework being used at runtime.
* Detection order matters to avoid false positives (e.g., Next.js includes React).
*/
function detectFramework() {
	if (typeof process !== "undefined" && process.env && (process.env.NEXT_RUNTIME || process.env.__NEXT_PRIVATE_ORIGIN)) return "next";
	if (typeof globalThis.window !== "undefined") {
		if (hasGlobalProperty("__NEXT_DATA__")) return "next";
		if (hasGlobalProperty("__remixContext")) return "remix";
		if (hasGlobalProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) return "react";
		if (hasGlobalProperty("__VUE__")) return "vue";
		if (hasGlobalProperty("Zone")) return "angular";
	}
}
function getClientInfo(sdkName, sdkVersion) {
	const base = {
		sdk: sdkName,
		version: sdkVersion,
		runtime: "unknown",
		runtimeVersion: "unknown",
		platform: "unknown",
		arch: "unknown"
	};
	let result;
	if (typeof process !== "undefined" && process.versions?.node) result = {
		...base,
		runtime: "node",
		runtimeVersion: process.versions.node,
		platform: process.platform,
		arch: process.arch
	};
	else if (typeof Deno !== "undefined") result = {
		...base,
		runtime: "deno",
		runtimeVersion: Deno.version?.deno ?? "unknown",
		platform: Deno.build?.os ?? "unknown",
		arch: Deno.build?.arch ?? "unknown"
	};
	else if (typeof Bun !== "undefined") result = {
		...base,
		runtime: "bun",
		runtimeVersion: Bun.version ?? "unknown",
		platform: process?.platform ?? "unknown",
		arch: process?.arch ?? "unknown"
	};
	else if (typeof EdgeRuntime !== "undefined" || typeof process !== "undefined" && !process.versions?.node && typeof globalThis.window === "undefined" && typeof document === "undefined") result = {
		...base,
		runtime: "edge"
	};
	else if (globalThis.window !== void 0 && typeof document !== "undefined") result = {
		...base,
		runtime: "browser",
		runtimeVersion: "unknown",
		platform: "web",
		arch: "unknown"
	};
	else result = base;
	const framework = detectFramework();
	if (framework) result.framework = framework;
	return result;
}
function createClientInfoInjector(defaultSdkName, defaultSdkVersion) {
	const cachedClientInfo = JSON.stringify(getClientInfo(defaultSdkName, defaultSdkVersion));
	return function injectClientInfo$1(headers, sdkOverride) {
		const result = new Headers(headers);
		if (result.has(X_NEON_CLIENT_INFO_HEADER)) return result;
		const clientInfoString = sdkOverride ? JSON.stringify(getClientInfo(sdkOverride.name, sdkOverride.version)) : cachedClientInfo;
		result.set(X_NEON_CLIENT_INFO_HEADER, clientInfoString);
		return result;
	};
}

//#endregion
//#region src/utils/client-info.ts
const injectClientInfo = createClientInfoInjector(name, version);

//#endregion
//#region src/client/fetch-with-token.ts
/**
* Fetch wrapper that automatically injects authentication tokens
* Generic utility for adding token-based authentication to requests
*/
/**
* Error thrown when authentication is required but no token is available
*/
var AuthRequiredError = class extends Error {
	constructor(message = "Authentication required. A valid token is needed to access the resource.") {
		super(message);
		this.name = "AuthRequiredError";
	}
};
/**
* Creates a fetch wrapper that injects authentication tokens into every request
*
* This is a generic utility that can work with any token provider function.
* The token is resolved lazily on each request.
*
* @param getAccessToken - Async function that returns current access token
* @param customFetch - Optional custom fetch implementation
* @returns Wrapped fetch function with authentication headers
*/
function fetchWithToken(getAccessToken, customFetch) {
	const baseFetch = customFetch ?? fetch;
	return async (input, init) => {
		const accessToken = await getAccessToken();
		if (!accessToken) throw new AuthRequiredError();
		const headers = injectClientInfo(init?.headers);
		if (!headers.has("Authorization")) headers.set("Authorization", `Bearer ${accessToken}`);
		return baseFetch(input, {
			...init,
			headers
		});
	};
}

//#endregion
export { AuthRequiredError, NeonPostgrestClient, X_NEON_CLIENT_INFO_HEADER, fetchWithToken, getClientInfo, injectClientInfo };