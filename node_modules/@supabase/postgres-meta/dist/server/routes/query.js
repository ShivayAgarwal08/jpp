import { PostgresMeta } from '../../lib/index.js';
import * as Parser from '../../lib/Parser.js';
import { createConnectionConfig, extractRequestForLogging, translateErrorToResponseCode, } from '../utils.js';
const errorOnEmptyQuery = (request) => {
    if (!request.body.query) {
        throw new Error('query not found');
    }
};
export default async (fastify) => {
    fastify.post('/', async (request, reply) => {
        const statementTimeoutSecs = request.query.statementTimeoutSecs;
        errorOnEmptyQuery(request);
        const config = createConnectionConfig(request);
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.query(request.body.query, {
            trackQueryInSentry: true,
            statementQueryTimeout: statementTimeoutSecs,
            parameters: request.body.parameters,
        });
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(translateErrorToResponseCode(error));
            return { error: error.formattedError ?? error.message, ...error };
        }
        return data || [];
    });
    fastify.post('/format', async (request, reply) => {
        errorOnEmptyQuery(request);
        const { data, error } = await Parser.Format(request.body.query);
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(translateErrorToResponseCode(error));
            return { error: error.message };
        }
        return data;
    });
    fastify.post('/parse', async (request, reply) => {
        errorOnEmptyQuery(request);
        const { data, error } = Parser.Parse(request.body.query);
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(translateErrorToResponseCode(error));
            return { error: error.message };
        }
        return data;
    });
    fastify.post('/deparse', async (request, reply) => {
        const { data, error } = Parser.Deparse(request.body.ast);
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(translateErrorToResponseCode(error));
            return { error: error.message };
        }
        return data;
    });
};
//# sourceMappingURL=query.js.map