import { PostgresMeta } from '../../lib/index.js';
import { createConnectionConfig } from '../utils.js';
import { extractRequestForLogging } from '../utils.js';
export default async (fastify) => {
    fastify.get('/', async (request, reply) => {
        const config = createConnectionConfig(request);
        const includeSystemSchemas = request.query.include_system_schemas === 'true';
        const includedSchemas = request.query.included_schemas?.split(',');
        const excludedSchemas = request.query.excluded_schemas?.split(',');
        const limit = request.query.limit;
        const offset = request.query.offset;
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.functions.list({
            includeSystemSchemas,
            includedSchemas,
            excludedSchemas,
            limit,
            offset,
        });
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(500);
            return { error: error.message };
        }
        return data;
    });
    fastify.get('/:id(\\d+)', async (request, reply) => {
        const config = createConnectionConfig(request);
        const id = Number(request.params.id);
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.functions.retrieve({ id });
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(404);
            return { error: error.message };
        }
        return data;
    });
    fastify.post('/', async (request, reply) => {
        const config = createConnectionConfig(request);
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.functions.create(request.body);
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(400);
            return { error: error.message };
        }
        return data;
    });
    fastify.patch('/:id(\\d+)', async (request, reply) => {
        const config = createConnectionConfig(request);
        const id = Number(request.params.id);
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.functions.update(id, request.body);
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(400);
            if (error.message.startsWith('Cannot find'))
                reply.code(404);
            return { error: error.message };
        }
        return data;
    });
    fastify.delete('/:id(\\d+)', async (request, reply) => {
        const config = createConnectionConfig(request);
        const id = Number(request.params.id);
        const pgMeta = new PostgresMeta(config);
        const { data, error } = await pgMeta.functions.remove(id);
        await pgMeta.end();
        if (error) {
            request.log.error({ error, request: extractRequestForLogging(request) });
            reply.code(400);
            if (error.message.startsWith('Cannot find'))
                reply.code(404);
            return { error: error.message };
        }
        return data;
    });
};
//# sourceMappingURL=functions.js.map