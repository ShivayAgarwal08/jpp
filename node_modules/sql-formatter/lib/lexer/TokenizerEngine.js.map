{"version":3,"file":"TokenizerEngine.js","names":["lineColFromIndex","WHITESPACE_REGEX","TokenizerEngine","input","index","constructor","rules","dialectName","tokenize","tokens","token","length","precedingWhitespace","getWhitespace","getNextToken","createParseError","push","text","slice","line","col","Error","dialectInfo","lastIndex","matches","exec","undefined","rule","match","regex","matchedText","type","raw","start","key"],"sources":["../../src/lexer/TokenizerEngine.ts"],"sourcesContent":["import { Token, TokenType } from './token.js';\nimport { lineColFromIndex } from './lineColFromIndex.js';\nimport { WHITESPACE_REGEX } from './regexUtil.js';\n\nexport interface RegExpLike {\n  lastIndex: number;\n  exec(input: string): string[] | null;\n}\n\nexport interface TokenRule {\n  type: TokenType;\n  // Normally a RegExp object.\n  // But to allow for more complex matching logic,\n  // an object can be given that implements a RegExpLike interface.\n  regex: RegExpLike;\n  // Called with the raw string that was matched\n  text?: (rawText: string) => string;\n  key?: (rawText: string) => string;\n}\n\nexport default class TokenizerEngine {\n  private input = ''; // The input SQL string to process\n  private index = 0; // Current position in string\n\n  constructor(private rules: TokenRule[], private dialectName: string) {}\n\n  /**\n   * Takes a SQL string and breaks it into tokens.\n   * Each token is an object with type and value.\n   *\n   * @param {string} input - The SQL string\n   * @returns {Token[]} output token stream\n   */\n  public tokenize(input: string): Token[] {\n    this.input = input;\n    this.index = 0;\n    const tokens: Token[] = [];\n    let token: Token | undefined;\n\n    // Keep processing the string until end is reached\n    while (this.index < this.input.length) {\n      // skip any preceding whitespace\n      const precedingWhitespace = this.getWhitespace();\n\n      if (this.index < this.input.length) {\n        // Get the next token and the token type\n        token = this.getNextToken();\n        if (!token) {\n          throw this.createParseError();\n        }\n\n        tokens.push({ ...token, precedingWhitespace });\n      }\n    }\n    return tokens;\n  }\n\n  private createParseError(): Error {\n    const text = this.input.slice(this.index, this.index + 10);\n    const { line, col } = lineColFromIndex(this.input, this.index);\n    return new Error(\n      `Parse error: Unexpected \"${text}\" at line ${line} column ${col}.\\n${this.dialectInfo()}`\n    );\n  }\n\n  private dialectInfo(): string {\n    if (this.dialectName === 'sql') {\n      return (\n        `This likely happens because you're using the default \"sql\" dialect.\\n` +\n        `If possible, please select a more specific dialect (like sqlite, postgresql, etc).`\n      );\n    } else {\n      return `SQL dialect used: \"${this.dialectName}\".`;\n    }\n  }\n\n  private getWhitespace(): string | undefined {\n    WHITESPACE_REGEX.lastIndex = this.index;\n\n    const matches = WHITESPACE_REGEX.exec(this.input);\n    if (matches) {\n      // Advance current position by matched whitespace length\n      this.index += matches[0].length;\n      return matches[0];\n    }\n    return undefined;\n  }\n\n  private getNextToken(): Token | undefined {\n    for (const rule of this.rules) {\n      const token = this.match(rule);\n      if (token) {\n        return token;\n      }\n    }\n    return undefined;\n  }\n\n  // Attempts to match token rule regex at current position in input\n  private match(rule: TokenRule): Token | undefined {\n    rule.regex.lastIndex = this.index;\n    const matches = rule.regex.exec(this.input);\n    if (matches) {\n      const matchedText = matches[0];\n\n      const token: Token = {\n        type: rule.type,\n        raw: matchedText,\n        text: rule.text ? rule.text(matchedText) : matchedText,\n        start: this.index,\n      };\n\n      if (rule.key) {\n        token.key = rule.key(matchedText);\n      }\n\n      // Advance current position by matched token length\n      this.index += matchedText.length;\n      return token;\n    }\n    return undefined;\n  }\n}\n"],"mappings":"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"}