"use strict";
/**
 * Auto-generated file with types stripped for better tree-shaking
 * DO NOT EDIT - Generated by strip-transformer-types.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.V16ToV17Transformer = void 0;
// @ts-nocheck
/**
 * V16 to V17 AST Transformer
 * Transforms PostgreSQL v16 AST nodes to v17 format
 */
class V16ToV17Transformer {
    transform(node, context = { parentNodeTypes: [] }) {
        if (node == null) {
            return null;
        }
        if (typeof node === 'number' || node instanceof Number) {
            return node;
        }
        if (typeof node === 'string') {
            return node;
        }
        try {
            return this.visit(node, context);
        }
        catch (error) {
            const nodeType = Object.keys(node)[0];
            throw new Error(`Error transforming ${nodeType}: ${error.message}`);
        }
    }
    visit(node, context = { parentNodeTypes: [] }) {
        const nodeType = this.getNodeType(node);
        // Handle empty objects
        if (!nodeType) {
            return {};
        }
        const nodeData = this.getNodeData(node);
        const methodName = nodeType;
        if (typeof this[methodName] === 'function') {
            const childContext = {
                ...context,
                parentNodeTypes: [...context.parentNodeTypes, nodeType]
            };
            const result = this[methodName](nodeData, childContext);
            return result;
        }
        // If no specific method, return the node as-is
        return node;
    }
    getNodeType(node) {
        return Object.keys(node)[0];
    }
    getNodeData(node) {
        const keys = Object.keys(node);
        if (keys.length === 1 && typeof node[keys[0]] === 'object') {
            return node[keys[0]];
        }
        return node;
    }
    ParseResult(node, context) {
        if (node && typeof node === 'object' && 'version' in node && 'stmts' in node) {
            return {
                version: 170004, // PG17 version
                stmts: node.stmts.map((stmt) => {
                    if (stmt && typeof stmt === 'object' && 'stmt' in stmt) {
                        return {
                            ...stmt,
                            stmt: this.transform(stmt.stmt, context)
                        };
                    }
                    return this.transform(stmt, context);
                })
            };
        }
        return node;
    }
    RawStmt(node, context) {
        const result = {};
        if (node.stmt !== undefined) {
            result.stmt = this.transform(node.stmt, context);
        }
        if (node.stmt_location !== undefined) {
            result.stmt_location = node.stmt_location;
        }
        if (node.stmt_len !== undefined) {
            result.stmt_len = node.stmt_len;
        }
        return { RawStmt: result };
    }
    SelectStmt(node, context) {
        const result = {};
        if (node.distinctClause !== undefined) {
            result.distinctClause = Array.isArray(node.distinctClause)
                ? node.distinctClause.map(item => this.transform(item, context))
                : this.transform(node.distinctClause, context);
        }
        if (node.intoClause !== undefined) {
            result.intoClause = this.transform(node.intoClause, context);
        }
        if (node.targetList !== undefined) {
            result.targetList = Array.isArray(node.targetList)
                ? node.targetList.map(item => this.transform(item, context))
                : this.transform(node.targetList, context);
        }
        if (node.fromClause !== undefined) {
            result.fromClause = Array.isArray(node.fromClause)
                ? node.fromClause.map(item => this.transform(item, context))
                : this.transform(node.fromClause, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.groupClause !== undefined) {
            result.groupClause = Array.isArray(node.groupClause)
                ? node.groupClause.map(item => this.transform(item, context))
                : this.transform(node.groupClause, context);
        }
        if (node.groupDistinct !== undefined) {
            result.groupDistinct = node.groupDistinct;
        }
        if (node.havingClause !== undefined) {
            result.havingClause = this.transform(node.havingClause, context);
        }
        if (node.windowClause !== undefined) {
            result.windowClause = Array.isArray(node.windowClause)
                ? node.windowClause.map(item => this.transform(item, context))
                : this.transform(node.windowClause, context);
        }
        if (node.valuesLists !== undefined) {
            const valuesContext = {
                ...context,
                inValuesClause: true
            };
            result.valuesLists = Array.isArray(node.valuesLists)
                ? node.valuesLists.map(item => Array.isArray(item)
                    ? item.map(subItem => this.transform(subItem, valuesContext))
                    : this.transform(item, valuesContext))
                : this.transform(node.valuesLists, valuesContext);
        }
        if (node.sortClause !== undefined) {
            result.sortClause = Array.isArray(node.sortClause)
                ? node.sortClause.map(item => this.transform(item, context))
                : this.transform(node.sortClause, context);
        }
        if (node.limitOffset !== undefined) {
            result.limitOffset = this.transform(node.limitOffset, context);
        }
        if (node.limitCount !== undefined) {
            result.limitCount = this.transform(node.limitCount, context);
        }
        if (node.limitOption !== undefined) {
            result.limitOption = node.limitOption;
        }
        if (node.lockingClause !== undefined) {
            result.lockingClause = Array.isArray(node.lockingClause)
                ? node.lockingClause.map(item => this.transform(item, context))
                : this.transform(node.lockingClause, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.all !== undefined) {
            result.all = node.all;
        }
        if (node.larg !== undefined) {
            result.larg = this.transform(node.larg, context);
        }
        if (node.rarg !== undefined) {
            result.rarg = this.transform(node.rarg, context);
        }
        return { SelectStmt: result };
    }
    A_Expr(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.name !== undefined) {
            result.name = Array.isArray(node.name)
                ? node.name.map(item => this.transform(item, context))
                : this.transform(node.name, context);
        }
        if (node.lexpr !== undefined) {
            result.lexpr = this.transform(node.lexpr, context);
        }
        if (node.rexpr !== undefined) {
            result.rexpr = this.transform(node.rexpr, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { A_Expr: result };
    }
    InsertStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.cols !== undefined) {
            result.cols = Array.isArray(node.cols)
                ? node.cols.map(item => this.transform(item, context))
                : this.transform(node.cols, context);
        }
        if (node.selectStmt !== undefined) {
            result.selectStmt = this.transform(node.selectStmt, context);
        }
        if (node.onConflictClause !== undefined) {
            result.onConflictClause = this.transform(node.onConflictClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map(item => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        if (node.override !== undefined) {
            result.override = node.override;
        }
        return { InsertStmt: result };
    }
    UpdateStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.targetList !== undefined) {
            result.targetList = Array.isArray(node.targetList)
                ? node.targetList.map(item => this.transform(item, context))
                : this.transform(node.targetList, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.fromClause !== undefined) {
            result.fromClause = Array.isArray(node.fromClause)
                ? node.fromClause.map(item => this.transform(item, context))
                : this.transform(node.fromClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map(item => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        return { UpdateStmt: result };
    }
    DeleteStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.usingClause !== undefined) {
            result.usingClause = Array.isArray(node.usingClause)
                ? node.usingClause.map(item => this.transform(item, context))
                : this.transform(node.usingClause, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map(item => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        return { DeleteStmt: result };
    }
    WithClause(node, context) {
        const result = {};
        if (node.ctes !== undefined) {
            const cteContext = { ...context, inCTE: true };
            result.ctes = Array.isArray(node.ctes)
                ? node.ctes.map(item => this.transform(item, cteContext))
                : this.transform(node.ctes, cteContext);
        }
        if (node.recursive !== undefined) {
            result.recursive = node.recursive;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { WithClause: result };
    }
    ResTarget(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.indirection !== undefined) {
            result.indirection = Array.isArray(node.indirection)
                ? node.indirection.map(item => this.transform(item, context))
                : this.transform(node.indirection, context);
        }
        if (node.val !== undefined) {
            result.val = this.transform(node.val, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ResTarget: result };
    }
    BoolExpr(node, context) {
        const result = {};
        if (node.boolop !== undefined) {
            result.boolop = node.boolop;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map(item => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { BoolExpr: result };
    }
    FuncCall(node, context) {
        const result = {};
        if (node.funcname !== undefined) {
            result.funcname = Array.isArray(node.funcname)
                ? node.funcname.map(item => this.transform(item, context))
                : this.transform(node.funcname, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map(item => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.agg_order !== undefined) {
            result.agg_order = Array.isArray(node.agg_order)
                ? node.agg_order.map(item => this.transform(item, context))
                : this.transform(node.agg_order, context);
        }
        if (node.agg_filter !== undefined) {
            result.agg_filter = this.transform(node.agg_filter, context);
        }
        if (node.agg_within_group !== undefined) {
            result.agg_within_group = node.agg_within_group;
        }
        if (node.agg_star !== undefined) {
            result.agg_star = node.agg_star;
        }
        if (node.agg_distinct !== undefined) {
            result.agg_distinct = node.agg_distinct;
        }
        if (node.func_variadic !== undefined) {
            result.func_variadic = node.func_variadic;
        }
        if (node.over !== undefined) {
            result.over = this.transform(node.over, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        const funcformatValue = this.getFuncformatValue(node, result.funcname, context);
        result.funcformat = funcformatValue;
        return { FuncCall: result };
    }
    FuncExpr(node, context) {
        return { FuncExpr: node };
    }
    A_Const(node, context) {
        return { A_Const: node };
    }
    ColumnRef(node, context) {
        return { ColumnRef: node };
    }
    isInCreateDomainContext(context) {
        return context.parentNodeTypes.includes('CreateDomainStmt');
    }
    isInTypeCastContext(context) {
        return context.parentNodeTypes.includes('TypeCast');
    }
    isInCreateTableContext(context) {
        return context.parentNodeTypes.includes('ColumnDef');
    }
    isInValuesContext(context) {
        return context.inValuesClause === true;
    }
    isInSimpleSelectTypeCastContext(context) {
        return context.parentNodeTypes.includes('TypeCast') &&
            context.parentNodeTypes.includes('ResTarget') &&
            !this.isInValuesContext(context);
    }
    shouldAddPgCatalogPrefix(context) {
        const hasSelectStmt = context.parentNodeTypes.includes('SelectStmt');
        const hasWithClause = context.parentNodeTypes.includes('WithClause');
        const hasCommonTableExpr = context.parentNodeTypes.includes('CommonTableExpr');
        return hasSelectStmt && !hasWithClause && !hasCommonTableExpr;
    }
    TypeName(node, context) {
        const result = {};
        if (node.names !== undefined) {
            let names = Array.isArray(node.names)
                ? node.names.map(item => this.transform(item, context))
                : this.transform(node.names, context);
            // Add pg_catalog prefix for JSON types in CREATE TABLE contexts
            if (Array.isArray(names) && names.length === 1) {
                const firstElement = names[0];
                if (firstElement && typeof firstElement === 'object' && 'String' in firstElement) {
                    const typeNameStr = firstElement.String.str || firstElement.String.sval;
                    if (typeNameStr === 'json') {
                        const hasCreateStmt = context.parentNodeTypes.includes('CreateStmt');
                        const hasCompositeTypeStmt = context.parentNodeTypes.includes('CompositeTypeStmt');
                        const hasRangeFunction = context.parentNodeTypes.includes('RangeFunction');
                        const hasCreateDomainStmt = context.parentNodeTypes.includes('CreateDomainStmt');
                        const hasColumnDef = context.parentNodeTypes.includes('ColumnDef');
                        if ((hasCreateStmt || hasCompositeTypeStmt || hasRangeFunction) && hasColumnDef) {
                            const pgCatalogElement = {
                                String: {
                                    sval: 'pg_catalog'
                                }
                            };
                            names = [pgCatalogElement, firstElement];
                        }
                        else if (hasCreateDomainStmt) {
                            const pgCatalogElement = {
                                String: {
                                    sval: 'pg_catalog'
                                }
                            };
                            names = [pgCatalogElement, firstElement];
                        }
                    }
                }
            }
            result.names = names;
        }
        if (node.typeOid !== undefined) {
            result.typeOid = node.typeOid;
        }
        if (node.setof !== undefined) {
            result.setof = node.setof;
        }
        if (node.pct_type !== undefined) {
            result.pct_type = node.pct_type;
        }
        if (node.typmods !== undefined) {
            result.typmods = Array.isArray(node.typmods)
                ? node.typmods.map(item => this.transform(item, context))
                : this.transform(node.typmods, context);
        }
        if (node.typemod !== undefined) {
            result.typemod = node.typemod;
        }
        if (node.arrayBounds !== undefined) {
            result.arrayBounds = Array.isArray(node.arrayBounds)
                ? node.arrayBounds.map(item => this.transform(item, context))
                : this.transform(node.arrayBounds, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { TypeName: result };
    }
    Alias(node, context) {
        return { Alias: node };
    }
    RangeVar(node, context) {
        const result = {};
        if (node.catalogname !== undefined) {
            result.catalogname = node.catalogname;
        }
        if (node.schemaname !== undefined) {
            result.schemaname = node.schemaname;
        }
        if (node.relname !== undefined) {
            result.relname = node.relname;
        }
        if (node.inh !== undefined) {
            result.inh = node.inh;
        }
        if (node.relpersistence !== undefined) {
            result.relpersistence = node.relpersistence;
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RangeVar: result };
    }
    A_ArrayExpr(node, context) {
        return { A_ArrayExpr: node };
    }
    A_Indices(node, context) {
        return { A_Indices: node };
    }
    A_Indirection(node, context) {
        return { A_Indirection: node };
    }
    A_Star(node, context) {
        return { A_Star: node };
    }
    CaseExpr(node, context) {
        return { CaseExpr: node };
    }
    CoalesceExpr(node, context) {
        return { CoalesceExpr: node };
    }
    TypeCast(node, context) {
        const result = {};
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.typeName !== undefined) {
            let typeName = this.transform(node.typeName, context);
            // Add pg_catalog prefix for JSON types in simple SELECT contexts, but NOT in WITH clauses
            if (typeName && typeName.names && Array.isArray(typeName.names) && typeName.names.length === 1) {
                const firstElement = typeName.names[0];
                if (firstElement && typeof firstElement === 'object' && 'String' in firstElement) {
                    const typeNameStr = firstElement.String.str || firstElement.String.sval;
                    if (typeNameStr === 'json') {
                        const hasSelectStmt = context.parentNodeTypes.includes('SelectStmt');
                        const hasResTarget = context.parentNodeTypes.includes('ResTarget');
                        const hasList = context.parentNodeTypes.includes('List');
                        const hasA_Expr = context.parentNodeTypes.includes('A_Expr');
                        const hasWithClause = context.parentNodeTypes.includes('WithClause');
                        const hasCommonTableExpr = context.parentNodeTypes.includes('CommonTableExpr');
                        if (((hasSelectStmt && hasResTarget) || (hasSelectStmt && hasList) || hasA_Expr) && !hasWithClause && !hasCommonTableExpr) {
                            const pgCatalogElement = {
                                String: {
                                    sval: 'pg_catalog'
                                }
                            };
                            typeName.names = [pgCatalogElement, firstElement];
                        }
                    }
                }
            }
            result.typeName = typeName;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { TypeCast: result };
    }
    CollateClause(node, context) {
        return { CollateClause: node };
    }
    BooleanTest(node, context) {
        return { BooleanTest: node };
    }
    NullTest(node, context) {
        return { NullTest: node };
    }
    String(node, context) {
        return { String: node };
    }
    Integer(node, context) {
        return { Integer: node };
    }
    Float(node, context) {
        return { Float: node };
    }
    Boolean(node, context) {
        return { Boolean: node };
    }
    BitString(node, context) {
        return { BitString: node };
    }
    // NOTE: there is no Null type in PG17
    Null(node, context) {
        return { Null: node };
    }
    List(node, context) {
        const result = {};
        if (node.items !== undefined) {
            result.items = Array.isArray(node.items)
                ? node.items.map(item => this.transform(item, context))
                : this.transform(node.items, context);
        }
        return { List: result };
    }
    CreateStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.tableElts !== undefined) {
            result.tableElts = Array.isArray(node.tableElts)
                ? node.tableElts.map(item => this.transform(item, context))
                : this.transform(node.tableElts, context);
        }
        if (node.inhRelations !== undefined) {
            result.inhRelations = Array.isArray(node.inhRelations)
                ? node.inhRelations.map(item => this.transform(item, context))
                : this.transform(node.inhRelations, context);
        }
        if (node.partbound !== undefined) {
            result.partbound = this.transform(node.partbound, context);
        }
        if (node.partspec !== undefined) {
            result.partspec = this.transform(node.partspec, context);
        }
        if (node.ofTypename !== undefined) {
            result.ofTypename = this.transform(node.ofTypename, context);
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map(item => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map(item => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.oncommit !== undefined) {
            result.oncommit = node.oncommit;
        }
        if (node.tablespacename !== undefined) {
            result.tablespacename = node.tablespacename;
        }
        if (node.accessMethod !== undefined) {
            result.accessMethod = node.accessMethod;
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        return { CreateStmt: result };
    }
    ColumnDef(node, context) {
        const result = {};
        if (node.colname !== undefined) {
            result.colname = node.colname;
        }
        if (node.typeName !== undefined) {
            const transformedTypeName = this.TypeName(node.typeName, context);
            result.typeName = transformedTypeName.TypeName;
        }
        if (node.inhcount !== undefined) {
            result.inhcount = node.inhcount;
        }
        if (node.is_local !== undefined) {
            result.is_local = node.is_local;
        }
        if (node.is_not_null !== undefined) {
            result.is_not_null = node.is_not_null;
        }
        if (node.is_from_type !== undefined) {
            result.is_from_type = node.is_from_type;
        }
        if (node.storage !== undefined) {
            result.storage = node.storage;
        }
        if (node.raw_default !== undefined) {
            result.raw_default = this.transform(node.raw_default, context);
        }
        if (node.cooked_default !== undefined) {
            result.cooked_default = this.transform(node.cooked_default, context);
        }
        if (node.identity !== undefined) {
            result.identity = node.identity;
        }
        if (node.identitySequence !== undefined) {
            result.identitySequence = this.transform(node.identitySequence, context);
        }
        if (node.generated !== undefined) {
            result.generated = node.generated;
        }
        if (node.collClause !== undefined) {
            result.collClause = this.transform(node.collClause, context);
        }
        if (node.collOid !== undefined) {
            result.collOid = node.collOid;
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map(item => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        if (node.fdwoptions !== undefined) {
            result.fdwoptions = Array.isArray(node.fdwoptions)
                ? node.fdwoptions.map(item => this.transform(item, context))
                : this.transform(node.fdwoptions, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ColumnDef: result };
    }
    Constraint(node, context) {
        return { Constraint: node };
    }
    SubLink(node, context) {
        return { SubLink: node };
    }
    CaseWhen(node, context) {
        return { CaseWhen: node };
    }
    WindowDef(node, context) {
        return { WindowDef: node };
    }
    SortBy(node, context) {
        return { SortBy: node };
    }
    GroupingSet(node, context) {
        return { GroupingSet: node };
    }
    CommonTableExpr(node, context) {
        const result = {};
        if (node.ctename !== undefined) {
            result.ctename = node.ctename;
        }
        if (node.aliascolnames !== undefined) {
            result.aliascolnames = Array.isArray(node.aliascolnames)
                ? node.aliascolnames.map(item => this.transform(item, context))
                : this.transform(node.aliascolnames, context);
        }
        if (node.ctematerialized !== undefined) {
            result.ctematerialized = node.ctematerialized;
        }
        if (node.ctequery !== undefined) {
            result.ctequery = this.transform(node.ctequery, context);
        }
        if (node.search_clause !== undefined) {
            result.search_clause = this.transform(node.search_clause, context);
        }
        if (node.cycle_clause !== undefined) {
            result.cycle_clause = this.transform(node.cycle_clause, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CommonTableExpr: result };
    }
    ParamRef(node, context) {
        return { ParamRef: node };
    }
    LockingClause(node, context) {
        return { LockingClause: node };
    }
    MinMaxExpr(node, context) {
        return { MinMaxExpr: node };
    }
    RowExpr(node, context) {
        return { RowExpr: node };
    }
    OpExpr(node, context) {
        return { OpExpr: node };
    }
    DistinctExpr(node, context) {
        return { DistinctExpr: node };
    }
    NullIfExpr(node, context) {
        return { NullIfExpr: node };
    }
    ScalarArrayOpExpr(node, context) {
        return { ScalarArrayOpExpr: node };
    }
    Aggref(node, context) {
        return { Aggref: node };
    }
    WindowFunc(node, context) {
        return { WindowFunc: node };
    }
    FieldSelect(node, context) {
        return { FieldSelect: node };
    }
    RelabelType(node, context) {
        return { RelabelType: node };
    }
    CoerceViaIO(node, context) {
        return { CoerceViaIO: node };
    }
    ArrayCoerceExpr(node, context) {
        return { ArrayCoerceExpr: node };
    }
    ConvertRowtypeExpr(node, context) {
        return { ConvertRowtypeExpr: node };
    }
    NamedArgExpr(node, context) {
        return { NamedArgExpr: node };
    }
    ViewStmt(node, context) {
        return { ViewStmt: node };
    }
    IndexStmt(node, context) {
        return { IndexStmt: node };
    }
    IndexElem(node, context) {
        return { IndexElem: node };
    }
    PartitionElem(node, context) {
        return { PartitionElem: node };
    }
    PartitionCmd(node, context) {
        return { PartitionCmd: node };
    }
    JoinExpr(node, context) {
        return { JoinExpr: node };
    }
    FromExpr(node, context) {
        return { FromExpr: node };
    }
    TransactionStmt(node, context) {
        return { TransactionStmt: node };
    }
    VariableSetStmt(node, context) {
        return { VariableSetStmt: node };
    }
    VariableShowStmt(node, context) {
        return { VariableShowStmt: node };
    }
    CreateSchemaStmt(node, context) {
        return { CreateSchemaStmt: node };
    }
    RoleSpec(node, context) {
        return { RoleSpec: node };
    }
    DropStmt(node, context) {
        return { DropStmt: node };
    }
    TruncateStmt(node, context) {
        return { TruncateStmt: node };
    }
    ReturnStmt(node, context) {
        return { ReturnStmt: node };
    }
    PLAssignStmt(node, context) {
        return { PLAssignStmt: node };
    }
    CopyStmt(node, context) {
        return { CopyStmt: node };
    }
    AlterTableStmt(node, context) {
        return { AlterTableStmt: node };
    }
    AlterTableCmd(node, context) {
        return { AlterTableCmd: node };
    }
    CreateFunctionStmt(node, context) {
        return { CreateFunctionStmt: node };
    }
    FunctionParameter(node, context) {
        return { FunctionParameter: node };
    }
    CreateEnumStmt(node, context) {
        return { CreateEnumStmt: node };
    }
    CreateDomainStmt(node, context) {
        const result = {};
        if (node.domainname !== undefined) {
            result.domainname = Array.isArray(node.domainname)
                ? node.domainname.map(item => this.transform(item, context))
                : this.transform(node.domainname, context);
        }
        if (node.typeName !== undefined) {
            const transformedTypeName = this.TypeName(node.typeName, context);
            result.typeName = transformedTypeName.TypeName;
        }
        if (node.collClause !== undefined) {
            result.collClause = this.transform(node.collClause, context);
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map(item => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        return { CreateDomainStmt: result };
    }
    CreateRoleStmt(node, context) {
        return { CreateRoleStmt: node };
    }
    DefElem(node, context) {
        return { DefElem: node };
    }
    CreateTableSpaceStmt(node, context) {
        return { CreateTableSpaceStmt: node };
    }
    DropTableSpaceStmt(node, context) {
        return { DropTableSpaceStmt: node };
    }
    AlterTableSpaceOptionsStmt(node, context) {
        return { AlterTableSpaceOptionsStmt: node };
    }
    CreateExtensionStmt(node, context) {
        return { CreateExtensionStmt: node };
    }
    AlterExtensionStmt(node, context) {
        return { AlterExtensionStmt: node };
    }
    CreateFdwStmt(node, context) {
        return { CreateFdwStmt: node };
    }
    SetOperationStmt(node, context) {
        return { SetOperationStmt: node };
    }
    ReplicaIdentityStmt(node, context) {
        return { ReplicaIdentityStmt: node };
    }
    AlterCollationStmt(node, context) {
        return { AlterCollationStmt: node };
    }
    AlterDomainStmt(node, context) {
        return { AlterDomainStmt: node };
    }
    PrepareStmt(node, context) {
        return { PrepareStmt: node };
    }
    ExecuteStmt(node, context) {
        return { ExecuteStmt: node };
    }
    DeallocateStmt(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.name === undefined || node.name === null) {
            result.isall = true;
        }
        return { DeallocateStmt: result };
    }
    NotifyStmt(node, context) {
        return { NotifyStmt: node };
    }
    ListenStmt(node, context) {
        return { ListenStmt: node };
    }
    UnlistenStmt(node, context) {
        return { UnlistenStmt: node };
    }
    CheckPointStmt(node, context) {
        return { CheckPointStmt: node };
    }
    LoadStmt(node, context) {
        return { LoadStmt: node };
    }
    DiscardStmt(node, context) {
        return { DiscardStmt: node };
    }
    CommentStmt(node, context) {
        return { CommentStmt: node };
    }
    LockStmt(node, context) {
        return { LockStmt: node };
    }
    CreatePolicyStmt(node, context) {
        return { CreatePolicyStmt: node };
    }
    AlterPolicyStmt(node, context) {
        return { AlterPolicyStmt: node };
    }
    CreateUserMappingStmt(node, context) {
        return { CreateUserMappingStmt: node };
    }
    CreateStatsStmt(node, context) {
        return { CreateStatsStmt: node };
    }
    StatsElem(node, context) {
        return { StatsElem: node };
    }
    CreatePublicationStmt(node, context) {
        return { CreatePublicationStmt: node };
    }
    CreateSubscriptionStmt(node, context) {
        return { CreateSubscriptionStmt: node };
    }
    AlterPublicationStmt(node, context) {
        return { AlterPublicationStmt: node };
    }
    AlterSubscriptionStmt(node, context) {
        return { AlterSubscriptionStmt: node };
    }
    DropSubscriptionStmt(node, context) {
        return { DropSubscriptionStmt: node };
    }
    DoStmt(node, context) {
        return { DoStmt: node };
    }
    InlineCodeBlock(node, context) {
        return { InlineCodeBlock: node };
    }
    CallContext(node, context) {
        return { CallContext: node };
    }
    ConstraintsSetStmt(node, context) {
        return { ConstraintsSetStmt: node };
    }
    AlterSystemStmt(node, context) {
        return { AlterSystemStmt: node };
    }
    VacuumRelation(node, context) {
        return { VacuumRelation: node };
    }
    DropOwnedStmt(node, context) {
        return { DropOwnedStmt: node };
    }
    ReassignOwnedStmt(node, context) {
        return { ReassignOwnedStmt: node };
    }
    AlterTSDictionaryStmt(node, context) {
        return { AlterTSDictionaryStmt: node };
    }
    AlterTSConfigurationStmt(node, context) {
        return { AlterTSConfigurationStmt: node };
    }
    ClosePortalStmt(node, context) {
        return { ClosePortalStmt: node };
    }
    FetchStmt(node, context) {
        return { FetchStmt: node };
    }
    AlterStatsStmt(node, context) {
        return { AlterStatsStmt: node };
    }
    ObjectWithArgs(node, context) {
        return { ObjectWithArgs: node };
    }
    AlterOperatorStmt(node, context) {
        return { AlterOperatorStmt: node };
    }
    AlterFdwStmt(node, context) {
        return { AlterFdwStmt: node };
    }
    CreateForeignServerStmt(node, context) {
        return { CreateForeignServerStmt: node };
    }
    AlterForeignServerStmt(node, context) {
        return { AlterForeignServerStmt: node };
    }
    AlterUserMappingStmt(node, context) {
        return { AlterUserMappingStmt: node };
    }
    DropUserMappingStmt(node, context) {
        return { DropUserMappingStmt: node };
    }
    ImportForeignSchemaStmt(node, context) {
        return { ImportForeignSchemaStmt: node };
    }
    ClusterStmt(node, context) {
        return { ClusterStmt: node };
    }
    VacuumStmt(node, context) {
        return { VacuumStmt: node };
    }
    ExplainStmt(node, context) {
        return { ExplainStmt: node };
    }
    ReindexStmt(node, context) {
        return { ReindexStmt: node };
    }
    CallStmt(node, context) {
        return { CallStmt: node };
    }
    CreatedbStmt(node, context) {
        return { CreatedbStmt: node };
    }
    DropdbStmt(node, context) {
        return { DropdbStmt: node };
    }
    RenameStmt(node, context) {
        return { RenameStmt: node };
    }
    AlterOwnerStmt(node, context) {
        return { AlterOwnerStmt: node };
    }
    GrantStmt(node, context) {
        return { GrantStmt: node };
    }
    GrantRoleStmt(node, context) {
        return { GrantRoleStmt: node };
    }
    SecLabelStmt(node, context) {
        return { SecLabelStmt: node };
    }
    AlterDefaultPrivilegesStmt(node, context) {
        return { AlterDefaultPrivilegesStmt: node };
    }
    CreateConversionStmt(node, context) {
        return { CreateConversionStmt: node };
    }
    CreateCastStmt(node, context) {
        return { CreateCastStmt: node };
    }
    CreatePLangStmt(node, context) {
        return { CreatePLangStmt: node };
    }
    CreateTransformStmt(node, context) {
        return { CreateTransformStmt: node };
    }
    CreateTrigStmt(node, context) {
        return { CreateTrigStmt: node };
    }
    TriggerTransition(node, context) {
        return { TriggerTransition: node };
    }
    CreateEventTrigStmt(node, context) {
        return { CreateEventTrigStmt: node };
    }
    AlterEventTrigStmt(node, context) {
        return { AlterEventTrigStmt: node };
    }
    CreateOpClassStmt(node, context) {
        return { CreateOpClassStmt: node };
    }
    CreateOpFamilyStmt(node, context) {
        return { CreateOpFamilyStmt: node };
    }
    AlterOpFamilyStmt(node, context) {
        return { AlterOpFamilyStmt: node };
    }
    MergeStmt(node, context) {
        return { MergeStmt: node };
    }
    AlterTableMoveAllStmt(node, context) {
        return { AlterTableMoveAllStmt: node };
    }
    CreateSeqStmt(node, context) {
        return { CreateSeqStmt: node };
    }
    AlterSeqStmt(node, context) {
        return { AlterSeqStmt: node };
    }
    CompositeTypeStmt(node, context) {
        const result = {};
        if (node.typevar !== undefined) {
            result.typevar = this.transform(node.typevar, context);
        }
        if (node.coldeflist !== undefined) {
            result.coldeflist = Array.isArray(node.coldeflist)
                ? node.coldeflist.map(item => this.transform(item, context))
                : this.transform(node.coldeflist, context);
        }
        return { CompositeTypeStmt: result };
    }
    CreateRangeStmt(node, context) {
        return { CreateRangeStmt: node };
    }
    AlterEnumStmt(node, context) {
        return { AlterEnumStmt: node };
    }
    AlterTypeStmt(node, context) {
        return { AlterTypeStmt: node };
    }
    AlterRoleStmt(node, context) {
        return { AlterRoleStmt: node };
    }
    DropRoleStmt(node, context) {
        return { DropRoleStmt: node };
    }
    // NOTE PG 17 has a no CreateAggregateStmt?
    // In PostgreSQL 17, the CreateAggregateStmt has been removed from the backend parser infrastructure and replaced by CreateFunctionStmt with a kind = OBJECT_AGGREGATE variant.
    CreateAggregateStmt(node, context) {
        return { CreateAggregateStmt: node };
    }
    CreateTableAsStmt(node, context) {
        return { CreateTableAsStmt: node };
    }
    RefreshMatViewStmt(node, context) {
        return { RefreshMatViewStmt: node };
    }
    AccessPriv(node, context) {
        return { AccessPriv: node };
    }
    DefineStmt(node, context) {
        return { DefineStmt: node };
    }
    AlterDatabaseStmt(node, context) {
        return { AlterDatabaseStmt: node };
    }
    AlterDatabaseRefreshCollStmt(node, context) {
        return { AlterDatabaseRefreshCollStmt: node };
    }
    AlterDatabaseSetStmt(node, context) {
        return { AlterDatabaseSetStmt: node };
    }
    DeclareCursorStmt(node, context) {
        return { DeclareCursorStmt: node };
    }
    PublicationObjSpec(node, context) {
        return { PublicationObjSpec: node };
    }
    PublicationTable(node, context) {
        return { PublicationTable: node };
    }
    CreateAmStmt(node, context) {
        return { CreateAmStmt: node };
    }
    IntoClause(node, context) {
        return { IntoClause: node };
    }
    OnConflictExpr(node, context) {
        return { OnConflictExpr: node };
    }
    ScanToken(node, context) {
        return { ScanToken: node };
    }
    CreateOpClassItem(node, context) {
        return { CreateOpClassItem: node };
    }
    Var(node, context) {
        return { Var: node };
    }
    TableFunc(node, context) {
        return { TableFunc: node };
    }
    RangeTableFunc(node, context) {
        return { RangeTableFunc: node };
    }
    RangeTableFuncCol(node, context) {
        return { RangeTableFuncCol: node };
    }
    JsonArrayQueryConstructor(node, context) {
        return { JsonArrayQueryConstructor: node };
    }
    RangeFunction(node, context) {
        const result = {};
        if (node.lateral !== undefined) {
            result.lateral = node.lateral;
        }
        if (node.ordinality !== undefined) {
            result.ordinality = node.ordinality;
        }
        if (node.is_rowsfrom !== undefined) {
            result.is_rowsfrom = node.is_rowsfrom;
        }
        if (node.functions !== undefined) {
            result.functions = Array.isArray(node.functions)
                ? node.functions.map(item => this.transform(item, context))
                : this.transform(node.functions, context);
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        if (node.coldeflist !== undefined) {
            result.coldeflist = Array.isArray(node.coldeflist)
                ? node.coldeflist.map(item => this.transform(item, context))
                : this.transform(node.coldeflist, context);
        }
        return { RangeFunction: result };
    }
    XmlSerialize(node, context) {
        const result = {};
        if (node.xmloption !== undefined) {
            result.xmloption = node.xmloption;
        }
        if (node.expr !== undefined) {
            result.expr = this.transform(node.expr, context);
        }
        if (node.typeName !== undefined) {
            result.typeName = this.transform(node.typeName, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { XmlSerialize: result };
    }
    RuleStmt(node, context) {
        return { RuleStmt: node };
    }
    GroupingFunc(node, context) {
        const result = {};
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.refs !== undefined) {
            result.refs = Array.isArray(node.refs)
                ? node.refs.map((item) => this.transform(item, context))
                : this.transform(node.refs, context);
        }
        if (node.agglevelsup !== undefined) {
            result.agglevelsup = node.agglevelsup;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { GroupingFunc: result };
    }
    MultiAssignRef(node, context) {
        const result = {};
        if (node.source !== undefined) {
            result.source = this.transform(node.source, context);
        }
        if (node.colno !== undefined) {
            result.colno = node.colno;
        }
        if (node.ncolumns !== undefined) {
            result.ncolumns = node.ncolumns;
        }
        return { MultiAssignRef: result };
    }
    CurrentOfExpr(node, context) {
        const result = {};
        if (node.cursor_name !== undefined) {
            result.cursor_name = node.cursor_name;
        }
        if (node.cursor_param !== undefined) {
            result.cursor_param = node.cursor_param;
        }
        return { CurrentOfExpr: result };
    }
    TableLikeClause(node, context) {
        return { TableLikeClause: node };
    }
    AlterFunctionStmt(node, context) {
        return { AlterFunctionStmt: node };
    }
    AlterObjectSchemaStmt(node, context) {
        return { AlterObjectSchemaStmt: node };
    }
    AlterRoleSetStmt(node, context) {
        const result = {};
        if (node.role !== undefined) {
            result.role = this.transform(node.role, context);
        }
        if (node.database !== undefined) {
            result.database = node.database;
        }
        if (node.setstmt !== undefined) {
            result.setstmt = this.transform(node.setstmt, context);
        }
        return { AlterRoleSetStmt: result };
    }
    CreateForeignTableStmt(node, context) {
        return { CreateForeignTableStmt: node };
    }
    getFuncformatValue(node, funcname, context) {
        const functionName = this.getFunctionName(node, funcname);
        if (!functionName) {
            return 'COERCE_EXPLICIT_CALL';
        }
        const hasPgCatalogPrefix = this.hasPgCatalogPrefix(funcname);
        const sqlSyntaxFunctions = [
            'trim', 'ltrim', 'rtrim', 'btrim',
            'position', 'overlay', 'substring',
            'extract', 'timezone', 'xmlexists',
            'current_date', 'current_time', 'current_timestamp',
            'localtime', 'localtimestamp', 'overlaps'
        ];
        // Handle specific functions that depend on pg_catalog prefix
        if (functionName.toLowerCase() === 'substring') {
            if (hasPgCatalogPrefix) {
                return 'COERCE_SQL_SYNTAX';
            }
            return 'COERCE_EXPLICIT_CALL';
        }
        if (functionName.toLowerCase() === 'ltrim') {
            if (hasPgCatalogPrefix) {
                return 'COERCE_SQL_SYNTAX';
            }
            return 'COERCE_EXPLICIT_CALL';
        }
        if (functionName.toLowerCase() === 'btrim') {
            if (hasPgCatalogPrefix) {
                return 'COERCE_SQL_SYNTAX';
            }
            return 'COERCE_EXPLICIT_CALL';
        }
        if (functionName.toLowerCase() === 'pg_collation_for') {
            if (hasPgCatalogPrefix) {
                return 'COERCE_SQL_SYNTAX';
            }
            return 'COERCE_EXPLICIT_CALL';
        }
        if (sqlSyntaxFunctions.includes(functionName.toLowerCase())) {
            return 'COERCE_SQL_SYNTAX';
        }
        return 'COERCE_EXPLICIT_CALL';
    }
    getFunctionName(node, funcname) {
        const names = funcname || node?.funcname;
        if (names && Array.isArray(names) && names.length > 0) {
            const lastName = names[names.length - 1];
            if (lastName && typeof lastName === 'object' && 'String' in lastName) {
                return lastName.String.str || lastName.String.sval;
            }
        }
        return null;
    }
    hasPgCatalogPrefix(funcname) {
        if (funcname && Array.isArray(funcname) && funcname.length >= 2) {
            const firstElement = funcname[0];
            if (firstElement && typeof firstElement === 'object' && 'String' in firstElement) {
                const prefix = firstElement.String.str || firstElement.String.sval;
                return prefix === 'pg_catalog';
            }
        }
        return false;
    }
    RangeTableSample(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.method !== undefined) {
            result.method = Array.isArray(node.method)
                ? node.method.map(item => this.transform(item, context))
                : this.transform(node.method, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map(item => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.repeatable !== undefined) {
            result.repeatable = this.transform(node.repeatable, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RangeTableSample: result };
    }
    SQLValueFunction(node, context) {
        const result = {};
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.type !== undefined) {
            result.type = node.type;
        }
        if (node.typmod !== undefined) {
            result.typmod = node.typmod;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { SQLValueFunction: result };
    }
    XmlExpr(node, context) {
        const result = {};
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.named_args !== undefined) {
            result.named_args = Array.isArray(node.named_args)
                ? node.named_args.map(item => this.transform(item, context))
                : this.transform(node.named_args, context);
        }
        if (node.arg_names !== undefined) {
            result.arg_names = Array.isArray(node.arg_names)
                ? node.arg_names.map(item => this.transform(item, context))
                : this.transform(node.arg_names, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map(item => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.xmloption !== undefined) {
            result.xmloption = node.xmloption;
        }
        if (node.type !== undefined) {
            result.type = node.type;
        }
        if (node.typmod !== undefined) {
            result.typmod = node.typmod;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { XmlExpr: result };
    }
    RangeSubselect(node, context) {
        const result = {};
        if (node.lateral !== undefined) {
            result.lateral = node.lateral;
        }
        if (node.subquery !== undefined) {
            result.subquery = this.transform(node.subquery, context);
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        return { RangeSubselect: result };
    }
    SetToDefault(node, context) {
        const result = {};
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { SetToDefault: result };
    }
}
exports.V16ToV17Transformer = V16ToV17Transformer;
