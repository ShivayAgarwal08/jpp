/**
 * Auto-generated file with types stripped for better tree-shaking
 * DO NOT EDIT - Generated by strip-transformer-types.ts
 */
// @ts-nocheck
/**
 * V15 to V16 AST Transformer
 * Transforms PostgreSQL v15 AST nodes to v16 format
 */
export class V15ToV16Transformer {
    transform(node, context = { parentNodeTypes: [] }) {
        if (node == null) {
            return null;
        }
        if (typeof node === 'number' || node instanceof Number) {
            return node;
        }
        if (typeof node === 'string') {
            return node;
        }
        if (Array.isArray(node)) {
            return node.map(item => this.transform(item, context));
        }
        try {
            return this.visit(node, context);
        }
        catch (error) {
            const nodeType = Object.keys(node)[0];
            throw new Error(`Error transforming ${nodeType}: ${error.message}`);
        }
    }
    visit(node, context = { parentNodeTypes: [] }) {
        const nodeType = this.getNodeType(node);
        // Handle empty objects
        if (!nodeType) {
            return {};
        }
        const nodeData = this.getNodeData(node);
        const methodName = nodeType;
        if (typeof this[methodName] === 'function') {
            const childContext = {
                ...context,
                parentNodeTypes: [...(context.parentNodeTypes || []), nodeType]
            };
            return this[methodName](nodeData, childContext);
        }
        // If no specific method, return the node as-is
        return node;
    }
    getNodeType(node) {
        const keys = Object.keys(node);
        // Handle parse result structure with version and stmts
        if (keys.length === 2 && keys.includes('version') && keys.includes('stmts')) {
            return 'ParseResult';
        }
        return keys[0];
    }
    getNodeData(node) {
        const keys = Object.keys(node);
        if (keys.length === 1 && typeof node[keys[0]] === 'object') {
            return node[keys[0]];
        }
        return node;
    }
    ParseResult(node, context) {
        if (node && typeof node === 'object' && 'version' in node && 'stmts' in node) {
            return {
                version: 160000, // PG16 version
                stmts: node.stmts.map((stmt) => {
                    if (stmt && typeof stmt === 'object' && 'stmt' in stmt) {
                        return {
                            ...stmt,
                            stmt: this.transform(stmt.stmt, context)
                        };
                    }
                    return this.transform(stmt, context);
                })
            };
        }
        return node;
    }
    RawStmt(node, context) {
        const result = {};
        if (node.stmt !== undefined) {
            result.stmt = this.transform(node.stmt, context);
        }
        if (node.stmt_location !== undefined) {
            result.stmt_location = node.stmt_location;
        }
        if (node.stmt_len !== undefined) {
            result.stmt_len = node.stmt_len;
        }
        return { RawStmt: result };
    }
    SelectStmt(node, context) {
        const result = {};
        if (node.distinctClause !== undefined) {
            result.distinctClause = Array.isArray(node.distinctClause)
                ? node.distinctClause.map((item) => this.transform(item, context))
                : this.transform(node.distinctClause, context);
        }
        if (node.intoClause !== undefined) {
            result.intoClause = this.transform(node.intoClause, context);
        }
        if (node.targetList !== undefined) {
            result.targetList = Array.isArray(node.targetList)
                ? node.targetList.map((item) => this.transform(item, context))
                : this.transform(node.targetList, context);
        }
        if (node.fromClause !== undefined) {
            result.fromClause = Array.isArray(node.fromClause)
                ? node.fromClause.map((item) => this.transform(item, context))
                : this.transform(node.fromClause, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.groupClause !== undefined) {
            result.groupClause = Array.isArray(node.groupClause)
                ? node.groupClause.map((item) => this.transform(item, context))
                : this.transform(node.groupClause, context);
        }
        if (node.groupDistinct !== undefined) {
            result.groupDistinct = node.groupDistinct;
        }
        if (node.havingClause !== undefined) {
            result.havingClause = this.transform(node.havingClause, context);
        }
        if (node.windowClause !== undefined) {
            result.windowClause = Array.isArray(node.windowClause)
                ? node.windowClause.map((item) => this.transform(item, context))
                : this.transform(node.windowClause, context);
        }
        if (node.valuesLists !== undefined) {
            result.valuesLists = Array.isArray(node.valuesLists)
                ? node.valuesLists.map((item) => this.transform(item, context))
                : this.transform(node.valuesLists, context);
        }
        if (node.sortClause !== undefined) {
            result.sortClause = Array.isArray(node.sortClause)
                ? node.sortClause.map((item) => this.transform(item, context))
                : this.transform(node.sortClause, context);
        }
        if (node.limitOffset !== undefined) {
            result.limitOffset = this.transform(node.limitOffset, context);
        }
        if (node.limitCount !== undefined) {
            result.limitCount = this.transform(node.limitCount, context);
        }
        if (node.limitOption !== undefined) {
            result.limitOption = node.limitOption;
        }
        if (node.lockingClause !== undefined) {
            result.lockingClause = Array.isArray(node.lockingClause)
                ? node.lockingClause.map((item) => this.transform(item, context))
                : this.transform(node.lockingClause, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.all !== undefined) {
            result.all = node.all;
        }
        if (node.larg !== undefined) {
            result.larg = this.transform(node.larg, context);
        }
        if (node.rarg !== undefined) {
            result.rarg = this.transform(node.rarg, context);
        }
        return { SelectStmt: result };
    }
    A_Expr(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.name !== undefined) {
            result.name = Array.isArray(node.name)
                ? node.name.map((item) => this.transform(item, context))
                : this.transform(node.name, context);
        }
        if (node.lexpr !== undefined) {
            result.lexpr = this.transform(node.lexpr, context);
        }
        if (node.rexpr !== undefined) {
            result.rexpr = this.transform(node.rexpr, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { A_Expr: result };
    }
    InsertStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.cols !== undefined) {
            result.cols = Array.isArray(node.cols)
                ? node.cols.map((item) => this.transform(item, context))
                : this.transform(node.cols, context);
        }
        if (node.selectStmt !== undefined) {
            result.selectStmt = this.transform(node.selectStmt, context);
        }
        if (node.onConflictClause !== undefined) {
            result.onConflictClause = this.transform(node.onConflictClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map((item) => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        if (node.override !== undefined) {
            result.override = node.override;
        }
        return { InsertStmt: result };
    }
    UpdateStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.targetList !== undefined) {
            result.targetList = Array.isArray(node.targetList)
                ? node.targetList.map((item) => this.transform(item, context))
                : this.transform(node.targetList, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.fromClause !== undefined) {
            result.fromClause = Array.isArray(node.fromClause)
                ? node.fromClause.map((item) => this.transform(item, context))
                : this.transform(node.fromClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map((item) => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        return { UpdateStmt: result };
    }
    DeleteStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.usingClause !== undefined) {
            result.usingClause = Array.isArray(node.usingClause)
                ? node.usingClause.map((item) => this.transform(item, context))
                : this.transform(node.usingClause, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.returningList !== undefined) {
            result.returningList = Array.isArray(node.returningList)
                ? node.returningList.map((item) => this.transform(item, context))
                : this.transform(node.returningList, context);
        }
        if (node.withClause !== undefined) {
            result.withClause = this.transform(node.withClause, context);
        }
        return { DeleteStmt: result };
    }
    WithClause(node, context) {
        const result = {};
        if (node.ctes !== undefined) {
            result.ctes = Array.isArray(node.ctes)
                ? node.ctes.map((item) => this.transform(item, context))
                : this.transform(node.ctes, context);
        }
        if (node.recursive !== undefined) {
            result.recursive = node.recursive;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { WithClause: result };
    }
    ResTarget(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.indirection !== undefined) {
            result.indirection = Array.isArray(node.indirection)
                ? node.indirection.map((item) => this.transform(item, context))
                : this.transform(node.indirection, context);
        }
        if (node.val !== undefined) {
            result.val = this.transform(node.val, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ResTarget: result };
    }
    BoolExpr(node, context) {
        const result = {};
        if (node.boolop !== undefined) {
            result.boolop = node.boolop;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { BoolExpr: result };
    }
    FuncCall(node, context) {
        const result = {};
        if (node.funcname !== undefined) {
            if (node.funcname.length === 1 && node.funcname[0]?.String?.sval === 'json_object') {
                result.funcname = [
                    {
                        String: { sval: 'pg_catalog' }
                    },
                    { String: { sval: 'json_object' } }
                ];
            }
            else if (node.funcname.length === 2 &&
                node.funcname[0]?.String?.sval === 'pg_catalog' &&
                node.funcname[1]?.String?.sval === 'system_user' &&
                node.funcformat === 'COERCE_SQL_SYNTAX') {
                return {
                    ColumnRef: {
                        fields: [
                            { String: { sval: 'system_user' } }
                        ]
                    }
                };
            }
            else {
                result.funcname = Array.isArray(node.funcname)
                    ? node.funcname.map((item) => this.transform(item, context))
                    : this.transform(node.funcname, context);
            }
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.agg_order !== undefined) {
            result.agg_order = Array.isArray(node.agg_order)
                ? node.agg_order.map((item) => this.transform(item, context))
                : this.transform(node.agg_order, context);
        }
        if (node.agg_filter !== undefined) {
            result.agg_filter = this.transform(node.agg_filter, context);
        }
        if (node.over !== undefined) {
            result.over = this.transform(node.over, context);
        }
        if (node.agg_within_group !== undefined) {
            result.agg_within_group = node.agg_within_group;
        }
        if (node.agg_star !== undefined) {
            result.agg_star = node.agg_star;
        }
        if (node.agg_distinct !== undefined) {
            result.agg_distinct = node.agg_distinct;
        }
        if (node.func_variadic !== undefined) {
            result.func_variadic = node.func_variadic;
        }
        if (node.funcformat !== undefined) {
            result.funcformat = node.funcformat;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { FuncCall: result };
    }
    FuncExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.funcid !== undefined) {
            result.funcid = node.funcid;
        }
        if (node.funcresulttype !== undefined) {
            result.funcresulttype = node.funcresulttype;
        }
        if (node.funcretset !== undefined) {
            result.funcretset = node.funcretset;
        }
        if (node.funcvariadic !== undefined) {
            result.funcvariadic = node.funcvariadic;
        }
        if (node.funcformat !== undefined) {
            result.funcformat = node.funcformat;
        }
        if (node.funccollid !== undefined) {
            result.funccollid = node.funccollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { FuncExpr: result };
    }
    A_Const(node, context) {
        const result = { ...node };
        if (result.val) {
            const val = result.val;
            if (val.String && val.String.str !== undefined) {
                result.sval = val.String.str;
                delete result.val;
            }
            else if (val.Integer !== undefined) {
                result.ival = val.Integer;
                delete result.val;
            }
            else if (val.Float && val.Float.str !== undefined) {
                result.fval = val.Float.str;
                delete result.val;
            }
            else if (val.BitString && val.BitString.str !== undefined) {
                result.bsval = val.BitString.str;
                delete result.val;
            }
            else if (val.Null !== undefined) {
                delete result.val;
            }
        }
        return { A_Const: result };
    }
    ColumnRef(node, context) {
        if (node.fields && Array.isArray(node.fields) && node.fields.length === 1) {
            const field = node.fields[0];
            if (field?.String?.sval === 'system_user') {
                return {
                    FuncCall: {
                        funcname: [
                            { String: { sval: 'pg_catalog' } },
                            { String: { sval: 'system_user' } }
                        ],
                        funcformat: 'COERCE_SQL_SYNTAX'
                    }
                };
            }
        }
        const result = {};
        if (node.fields !== undefined) {
            result.fields = Array.isArray(node.fields)
                ? node.fields.map((item) => this.transform(item, context))
                : this.transform(node.fields, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ColumnRef: result };
    }
    TypeName(node, context) {
        const result = {};
        if (node.names !== undefined) {
            result.names = Array.isArray(node.names)
                ? node.names.map((item) => this.transform(item, context))
                : this.transform(node.names, context);
        }
        if (node.typeOid !== undefined) {
            result.typeOid = node.typeOid;
        }
        if (node.setof !== undefined) {
            result.setof = node.setof;
        }
        if (node.pct_type !== undefined) {
            result.pct_type = node.pct_type;
        }
        if (node.typmods !== undefined) {
            result.typmods = Array.isArray(node.typmods)
                ? node.typmods.map((item) => this.transform(item, context))
                : this.transform(node.typmods, context);
        }
        if (node.typemod !== undefined) {
            result.typemod = node.typemod;
        }
        if (node.arrayBounds !== undefined) {
            const childContext = {
                ...context,
                parentNodeTypes: [...(context.parentNodeTypes || []), 'TypeName']
            };
            result.arrayBounds = Array.isArray(node.arrayBounds)
                ? node.arrayBounds.map((item) => this.transform(item, childContext))
                : this.transform(node.arrayBounds, childContext);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { TypeName: result };
    }
    Alias(node, context) {
        const result = {};
        if (node.aliasname !== undefined) {
            result.aliasname = node.aliasname;
        }
        if (node.colnames !== undefined) {
            result.colnames = Array.isArray(node.colnames)
                ? node.colnames.map((item) => this.transform(item, context))
                : this.transform(node.colnames, context);
        }
        return { Alias: result };
    }
    RangeVar(node, context) {
        if (node.relname === 'system_user' && node.inh === true && node.relpersistence === 'p') {
            return {
                RangeFunction: {
                    functions: [
                        {
                            List: {
                                items: [
                                    {
                                        FuncCall: {
                                            funcname: [
                                                { String: { sval: 'pg_catalog' } },
                                                { String: { sval: 'system_user' } }
                                            ],
                                            funcformat: 'COERCE_SQL_SYNTAX'
                                        }
                                    },
                                    {}
                                ]
                            }
                        }
                    ]
                }
            };
        }
        const result = {};
        if (node.catalogname !== undefined) {
            result.catalogname = node.catalogname;
        }
        if (node.schemaname !== undefined) {
            result.schemaname = node.schemaname;
        }
        if (node.relname !== undefined) {
            result.relname = node.relname;
        }
        if (node.inh !== undefined) {
            result.inh = node.inh;
        }
        if (node.relpersistence !== undefined) {
            result.relpersistence = node.relpersistence;
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RangeVar: result };
    }
    A_ArrayExpr(node, context) {
        const result = {};
        if (node.elements !== undefined) {
            result.elements = Array.isArray(node.elements)
                ? node.elements.map((item) => this.transform(item, context))
                : this.transform(node.elements, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { A_ArrayExpr: result };
    }
    A_Indices(node, context) {
        const result = {};
        if (node.is_slice !== undefined) {
            result.is_slice = node.is_slice;
        }
        if (node.lidx !== undefined) {
            result.lidx = this.transform(node.lidx, context);
        }
        if (node.uidx !== undefined) {
            result.uidx = this.transform(node.uidx, context);
        }
        return { A_Indices: result };
    }
    A_Indirection(node, context) {
        const result = {};
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.indirection !== undefined) {
            result.indirection = Array.isArray(node.indirection)
                ? node.indirection.map((item) => this.transform(item, context))
                : this.transform(node.indirection, context);
        }
        return { A_Indirection: result };
    }
    A_Star(node, context) {
        const result = {};
        return { A_Star: result };
    }
    CaseExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.casetype !== undefined) {
            result.casetype = node.casetype;
        }
        if (node.casecollid !== undefined) {
            result.casecollid = node.casecollid;
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.defresult !== undefined) {
            result.defresult = this.transform(node.defresult, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CaseExpr: result };
    }
    CoalesceExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.coalescetype !== undefined) {
            result.coalescetype = node.coalescetype;
        }
        if (node.coalescecollid !== undefined) {
            result.coalescecollid = node.coalescecollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CoalesceExpr: result };
    }
    TypeCast(node, context) {
        const result = {};
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.typeName !== undefined) {
            const childContext = {
                ...context,
                parentNodeTypes: [...(context.parentNodeTypes || []), 'TypeCast']
            };
            result.typeName = this.TypeName(node.typeName, childContext).TypeName;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { TypeCast: result };
    }
    CollateClause(node, context) {
        const result = {};
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.collname !== undefined) {
            result.collname = Array.isArray(node.collname)
                ? node.collname.map((item) => this.transform(item, context))
                : this.transform(node.collname, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CollateClause: result };
    }
    BooleanTest(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.booltesttype !== undefined) {
            result.booltesttype = node.booltesttype;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { BooleanTest: result };
    }
    NullTest(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.nulltesttype !== undefined) {
            result.nulltesttype = node.nulltesttype;
        }
        if (node.argisrow !== undefined) {
            result.argisrow = node.argisrow;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { NullTest: result };
    }
    String(node, context) {
        const result = { ...node };
        return { String: result };
    }
    Integer(node, context) {
        const result = { ...node };
        return { Integer: result };
    }
    Float(node, context) {
        const result = { ...node };
        return { Float: result };
    }
    Boolean(node, context) {
        const result = { ...node };
        return { Boolean: result };
    }
    BitString(node, context) {
        const result = { ...node };
        return { BitString: result };
    }
    Null(node, context) {
        return { Null: {} };
    }
    List(node, context) {
        const result = {};
        if (node.items !== undefined) {
            result.items = Array.isArray(node.items)
                ? node.items.map((item) => {
                    const transformed = this.transform(item, context);
                    if (transformed === null) {
                        return {};
                    }
                    return transformed;
                })
                : this.transform(node.items, context);
        }
        return { List: result };
    }
    CreateStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.tableElts !== undefined) {
            result.tableElts = Array.isArray(node.tableElts)
                ? node.tableElts.map((item) => this.transform(item, context))
                : this.transform(node.tableElts, context);
        }
        if (node.inhRelations !== undefined) {
            result.inhRelations = Array.isArray(node.inhRelations)
                ? node.inhRelations.map((item) => this.transform(item, context))
                : this.transform(node.inhRelations, context);
        }
        if (node.partbound !== undefined) {
            result.partbound = this.transform(node.partbound, context);
        }
        if (node.partspec !== undefined) {
            // Handle partspec transformation directly since it's a plain object, not a wrapped node
            const partspec = { ...node.partspec };
            if (partspec.strategy !== undefined) {
                const strategyMap = {
                    'range': 'PARTITION_STRATEGY_RANGE',
                    'list': 'PARTITION_STRATEGY_LIST',
                    'hash': 'PARTITION_STRATEGY_HASH'
                };
                partspec.strategy = strategyMap[partspec.strategy] || partspec.strategy;
            }
            if (partspec.partParams !== undefined) {
                partspec.partParams = Array.isArray(partspec.partParams)
                    ? partspec.partParams.map((item) => this.transform(item, context))
                    : this.transform(partspec.partParams, context);
            }
            result.partspec = partspec;
        }
        if (node.ofTypename !== undefined) {
            result.ofTypename = this.transform(node.ofTypename, context);
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map((item) => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.oncommit !== undefined) {
            result.oncommit = node.oncommit;
        }
        if (node.tablespacename !== undefined) {
            result.tablespacename = node.tablespacename;
        }
        if (node.accessMethod !== undefined) {
            result.accessMethod = node.accessMethod;
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        return { CreateStmt: result };
    }
    ColumnDef(node, context) {
        const result = {};
        if (node.colname !== undefined) {
            result.colname = node.colname;
        }
        if (node.typeName !== undefined) {
            const transformedTypeName = this.transform({ TypeName: node.typeName }, context);
            result.typeName = transformedTypeName.TypeName;
        }
        if (node.inhcount !== undefined) {
            result.inhcount = node.inhcount;
        }
        if (node.is_local !== undefined) {
            result.is_local = node.is_local;
        }
        if (node.is_not_null !== undefined) {
            result.is_not_null = node.is_not_null;
        }
        if (node.is_from_type !== undefined) {
            result.is_from_type = node.is_from_type;
        }
        if (node.storage !== undefined) {
            result.storage = node.storage;
        }
        if (node.raw_default !== undefined) {
            result.raw_default = this.transform(node.raw_default, context);
        }
        if (node.cooked_default !== undefined) {
            result.cooked_default = this.transform(node.cooked_default, context);
        }
        if (node.identity !== undefined) {
            result.identity = node.identity;
        }
        if (node.identitySequence !== undefined) {
            result.identitySequence = this.transform(node.identitySequence, context);
        }
        if (node.generated !== undefined) {
            result.generated = node.generated;
        }
        if (node.collClause !== undefined) {
            result.collClause = this.transform(node.collClause, context);
        }
        if (node.collOid !== undefined) {
            result.collOid = node.collOid;
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map((item) => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        if (node.fdwoptions !== undefined) {
            result.fdwoptions = Array.isArray(node.fdwoptions)
                ? node.fdwoptions.map((item) => this.transform(item, context))
                : this.transform(node.fdwoptions, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ColumnDef: result };
    }
    Constraint(node, context) {
        const result = {};
        if (node.contype !== undefined) {
            result.contype = node.contype;
        }
        if (node.conname !== undefined) {
            result.conname = node.conname;
        }
        if (node.deferrable !== undefined) {
            result.deferrable = node.deferrable;
        }
        if (node.initdeferred !== undefined) {
            result.initdeferred = node.initdeferred;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        if (node.is_no_inherit !== undefined) {
            result.is_no_inherit = node.is_no_inherit;
        }
        if (node.raw_expr !== undefined) {
            result.raw_expr = this.transform(node.raw_expr, context);
        }
        if (node.cooked_expr !== undefined) {
            result.cooked_expr = node.cooked_expr;
        }
        if (node.generated_when !== undefined) {
            result.generated_when = node.generated_when;
        }
        if (node.keys !== undefined) {
            result.keys = Array.isArray(node.keys)
                ? node.keys.map((item) => this.transform(item, context))
                : this.transform(node.keys, context);
        }
        if (node.including !== undefined) {
            result.including = Array.isArray(node.including)
                ? node.including.map((item) => this.transform(item, context))
                : this.transform(node.including, context);
        }
        if (node.exclusions !== undefined) {
            result.exclusions = Array.isArray(node.exclusions)
                ? node.exclusions.map((item) => this.transform(item, context))
                : this.transform(node.exclusions, context);
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.indexname !== undefined) {
            result.indexname = node.indexname;
        }
        if (node.indexspace !== undefined) {
            result.indexspace = node.indexspace;
        }
        if (node.reset_default_tblspc !== undefined) {
            result.reset_default_tblspc = node.reset_default_tblspc;
        }
        if (node.access_method !== undefined) {
            result.access_method = node.access_method;
        }
        if (node.where_clause !== undefined) {
            result.where_clause = this.transform(node.where_clause, context);
        }
        if (node.pktable !== undefined) {
            result.pktable = this.transform(node.pktable, context);
        }
        if (node.fk_attrs !== undefined) {
            result.fk_attrs = Array.isArray(node.fk_attrs)
                ? node.fk_attrs.map((item) => this.transform(item, context))
                : this.transform(node.fk_attrs, context);
        }
        if (node.pk_attrs !== undefined) {
            result.pk_attrs = Array.isArray(node.pk_attrs)
                ? node.pk_attrs.map((item) => this.transform(item, context))
                : this.transform(node.pk_attrs, context);
        }
        if (node.fk_matchtype !== undefined) {
            result.fk_matchtype = node.fk_matchtype;
        }
        if (node.fk_upd_action !== undefined) {
            result.fk_upd_action = node.fk_upd_action;
        }
        if (node.fk_del_action !== undefined) {
            result.fk_del_action = node.fk_del_action;
        }
        if (node.old_conpfeqop !== undefined) {
            result.old_conpfeqop = Array.isArray(node.old_conpfeqop)
                ? node.old_conpfeqop.map((item) => this.transform(item, context))
                : this.transform(node.old_conpfeqop, context);
        }
        if (node.old_pktable_oid !== undefined) {
            result.old_pktable_oid = node.old_pktable_oid;
        }
        if (node.skip_validation !== undefined) {
            result.skip_validation = node.skip_validation;
        }
        if (node.initially_valid !== undefined) {
            result.initially_valid = node.initially_valid;
        }
        if (node.nulls_not_distinct !== undefined) {
            result.nulls_not_distinct = node.nulls_not_distinct;
        }
        return { Constraint: result };
    }
    SubLink(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.subLinkType !== undefined) {
            result.subLinkType = node.subLinkType;
        }
        if (node.subLinkId !== undefined) {
            result.subLinkId = node.subLinkId;
        }
        if (node.testexpr !== undefined) {
            result.testexpr = this.transform(node.testexpr, context);
        }
        if (node.operName !== undefined) {
            result.operName = Array.isArray(node.operName)
                ? node.operName.map((item) => this.transform(item, context))
                : this.transform(node.operName, context);
        }
        if (node.subselect !== undefined) {
            result.subselect = this.transform(node.subselect, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { SubLink: result };
    }
    CaseWhen(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.expr !== undefined) {
            result.expr = this.transform(node.expr, context);
        }
        if (node.result !== undefined) {
            result.result = this.transform(node.result, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CaseWhen: result };
    }
    WindowDef(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.refname !== undefined) {
            result.refname = node.refname;
        }
        if (node.partitionClause !== undefined) {
            result.partitionClause = Array.isArray(node.partitionClause)
                ? node.partitionClause.map((item) => this.transform(item, context))
                : this.transform(node.partitionClause, context);
        }
        if (node.orderClause !== undefined) {
            result.orderClause = Array.isArray(node.orderClause)
                ? node.orderClause.map((item) => this.transform(item, context))
                : this.transform(node.orderClause, context);
        }
        if (node.frameOptions !== undefined) {
            result.frameOptions = node.frameOptions;
        }
        if (node.startOffset !== undefined) {
            result.startOffset = this.transform(node.startOffset, context);
        }
        if (node.endOffset !== undefined) {
            result.endOffset = this.transform(node.endOffset, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { WindowDef: result };
    }
    SortBy(node, context) {
        const result = {};
        if (node.node !== undefined) {
            result.node = this.transform(node.node, context);
        }
        if (node.sortby_dir !== undefined) {
            result.sortby_dir = node.sortby_dir;
        }
        if (node.sortby_nulls !== undefined) {
            result.sortby_nulls = node.sortby_nulls;
        }
        if (node.useOp !== undefined) {
            result.useOp = Array.isArray(node.useOp)
                ? node.useOp.map((item) => this.transform(item, context))
                : this.transform(node.useOp, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { SortBy: result };
    }
    GroupingSet(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.content !== undefined) {
            result.content = Array.isArray(node.content)
                ? node.content.map((item) => this.transform(item, context))
                : this.transform(node.content, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { GroupingSet: result };
    }
    CommonTableExpr(node, context) {
        const result = {};
        if (node.ctename !== undefined) {
            result.ctename = node.ctename;
        }
        if (node.aliascolnames !== undefined) {
            result.aliascolnames = Array.isArray(node.aliascolnames)
                ? node.aliascolnames.map((item) => this.transform(item, context))
                : this.transform(node.aliascolnames, context);
        }
        if (node.ctematerialized !== undefined) {
            result.ctematerialized = node.ctematerialized;
        }
        if (node.ctequery !== undefined) {
            result.ctequery = this.transform(node.ctequery, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        if (node.cterecursive !== undefined) {
            result.cterecursive = node.cterecursive;
        }
        if (node.cterefcount !== undefined) {
            result.cterefcount = node.cterefcount;
        }
        if (node.ctecolnames !== undefined) {
            result.ctecolnames = Array.isArray(node.ctecolnames)
                ? node.ctecolnames.map((item) => this.transform(item, context))
                : this.transform(node.ctecolnames, context);
        }
        if (node.ctecoltypes !== undefined) {
            result.ctecoltypes = Array.isArray(node.ctecoltypes)
                ? node.ctecoltypes.map((item) => this.transform(item, context))
                : this.transform(node.ctecoltypes, context);
        }
        if (node.ctecoltypmods !== undefined) {
            result.ctecoltypmods = Array.isArray(node.ctecoltypmods)
                ? node.ctecoltypmods.map((item) => this.transform(item, context))
                : this.transform(node.ctecoltypmods, context);
        }
        if (node.ctecolcollations !== undefined) {
            result.ctecolcollations = Array.isArray(node.ctecolcollations)
                ? node.ctecolcollations.map((item) => this.transform(item, context))
                : this.transform(node.ctecolcollations, context);
        }
        return { CommonTableExpr: result };
    }
    ParamRef(node, context) {
        const result = {};
        if (node.number !== undefined) {
            result.number = node.number;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ParamRef: result };
    }
    LockingClause(node, context) {
        const result = {};
        if (node.lockedRels !== undefined) {
            result.lockedRels = Array.isArray(node.lockedRels)
                ? node.lockedRels.map((item) => this.transform(item, context))
                : this.transform(node.lockedRels, context);
        }
        if (node.strength !== undefined) {
            result.strength = node.strength;
        }
        if (node.waitPolicy !== undefined) {
            result.waitPolicy = node.waitPolicy;
        }
        return { LockingClause: result };
    }
    MinMaxExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.minmaxtype !== undefined) {
            result.minmaxtype = node.minmaxtype;
        }
        if (node.minmaxcollid !== undefined) {
            result.minmaxcollid = node.minmaxcollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { MinMaxExpr: result };
    }
    RowExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.row_typeid !== undefined) {
            result.row_typeid = node.row_typeid;
        }
        if (node.row_format !== undefined) {
            result.row_format = node.row_format;
        }
        if (node.colnames !== undefined) {
            result.colnames = Array.isArray(node.colnames)
                ? node.colnames.map((item) => this.transform(item, context))
                : this.transform(node.colnames, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RowExpr: result };
    }
    OpExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.opno !== undefined) {
            result.opno = node.opno;
        }
        if (node.opfuncid !== undefined) {
            result.opfuncid = node.opfuncid;
        }
        if (node.opresulttype !== undefined) {
            result.opresulttype = node.opresulttype;
        }
        if (node.opretset !== undefined) {
            result.opretset = node.opretset;
        }
        if (node.opcollid !== undefined) {
            result.opcollid = node.opcollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { OpExpr: result };
    }
    DistinctExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.opno !== undefined) {
            result.opno = node.opno;
        }
        if (node.opfuncid !== undefined) {
            result.opfuncid = node.opfuncid;
        }
        if (node.opresulttype !== undefined) {
            result.opresulttype = node.opresulttype;
        }
        if (node.opretset !== undefined) {
            result.opretset = node.opretset;
        }
        if (node.opcollid !== undefined) {
            result.opcollid = node.opcollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { DistinctExpr: result };
    }
    NullIfExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.opno !== undefined) {
            result.opno = node.opno;
        }
        if (node.opfuncid !== undefined) {
            result.opfuncid = node.opfuncid;
        }
        if (node.opresulttype !== undefined) {
            result.opresulttype = node.opresulttype;
        }
        if (node.opretset !== undefined) {
            result.opretset = node.opretset;
        }
        if (node.opcollid !== undefined) {
            result.opcollid = node.opcollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { NullIfExpr: result };
    }
    ScalarArrayOpExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.opno !== undefined) {
            result.opno = node.opno;
        }
        if (node.opfuncid !== undefined) {
            result.opfuncid = node.opfuncid;
        }
        if (node.hashfuncid !== undefined) {
            result.hashfuncid = node.hashfuncid;
        }
        if (node.useOr !== undefined) {
            result.useOr = node.useOr;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ScalarArrayOpExpr: result };
    }
    Aggref(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.aggfnoid !== undefined) {
            result.aggfnoid = node.aggfnoid;
        }
        if (node.aggtype !== undefined) {
            result.aggtype = node.aggtype;
        }
        if (node.aggcollid !== undefined) {
            result.aggcollid = node.aggcollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.aggtranstype !== undefined) {
            result.aggtranstype = node.aggtranstype;
        }
        if (node.aggargtypes !== undefined) {
            result.aggargtypes = Array.isArray(node.aggargtypes)
                ? node.aggargtypes.map((item) => this.transform(item, context))
                : this.transform(node.aggargtypes, context);
        }
        if (node.aggdirectargs !== undefined) {
            result.aggdirectargs = Array.isArray(node.aggdirectargs)
                ? node.aggdirectargs.map((item) => this.transform(item, context))
                : this.transform(node.aggdirectargs, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.aggorder !== undefined) {
            result.aggorder = Array.isArray(node.aggorder)
                ? node.aggorder.map((item) => this.transform(item, context))
                : this.transform(node.aggorder, context);
        }
        if (node.aggdistinct !== undefined) {
            result.aggdistinct = Array.isArray(node.aggdistinct)
                ? node.aggdistinct.map((item) => this.transform(item, context))
                : this.transform(node.aggdistinct, context);
        }
        if (node.aggfilter !== undefined) {
            result.aggfilter = this.transform(node.aggfilter, context);
        }
        if (node.aggstar !== undefined) {
            result.aggstar = node.aggstar;
        }
        if (node.aggvariadic !== undefined) {
            result.aggvariadic = node.aggvariadic;
        }
        if (node.aggkind !== undefined) {
            result.aggkind = node.aggkind;
        }
        if (node.agglevelsup !== undefined) {
            result.agglevelsup = node.agglevelsup;
        }
        if (node.aggsplit !== undefined) {
            result.aggsplit = node.aggsplit;
        }
        if (node.aggno !== undefined) {
            result.aggno = node.aggno;
        }
        if (node.aggtransno !== undefined) {
            result.aggtransno = node.aggtransno;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { Aggref: result };
    }
    WindowFunc(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.winfnoid !== undefined) {
            result.winfnoid = node.winfnoid;
        }
        if (node.wintype !== undefined) {
            result.wintype = node.wintype;
        }
        if (node.wincollid !== undefined) {
            result.wincollid = node.wincollid;
        }
        if (node.inputcollid !== undefined) {
            result.inputcollid = node.inputcollid;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.aggfilter !== undefined) {
            result.aggfilter = this.transform(node.aggfilter, context);
        }
        if (node.winref !== undefined) {
            result.winref = node.winref;
        }
        if (node.winstar !== undefined) {
            result.winstar = node.winstar;
        }
        if (node.winagg !== undefined) {
            result.winagg = node.winagg;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { WindowFunc: result };
    }
    FieldSelect(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.fieldnum !== undefined) {
            result.fieldnum = node.fieldnum;
        }
        if (node.resulttype !== undefined) {
            result.resulttype = node.resulttype;
        }
        if (node.resulttypmod !== undefined) {
            result.resulttypmod = node.resulttypmod;
        }
        if (node.resultcollid !== undefined) {
            result.resultcollid = node.resultcollid;
        }
        return { FieldSelect: result };
    }
    RelabelType(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.resulttype !== undefined) {
            result.resulttype = node.resulttype;
        }
        if (node.resulttypmod !== undefined) {
            result.resulttypmod = node.resulttypmod;
        }
        if (node.resultcollid !== undefined) {
            result.resultcollid = node.resultcollid;
        }
        if (node.relabelformat !== undefined) {
            result.relabelformat = node.relabelformat;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RelabelType: result };
    }
    CoerceViaIO(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.resulttype !== undefined) {
            result.resulttype = node.resulttype;
        }
        if (node.resultcollid !== undefined) {
            result.resultcollid = node.resultcollid;
        }
        if (node.coerceformat !== undefined) {
            result.coerceformat = node.coerceformat;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { CoerceViaIO: result };
    }
    ArrayCoerceExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.elemexpr !== undefined) {
            result.elemexpr = this.transform(node.elemexpr, context);
        }
        if (node.resulttype !== undefined) {
            result.resulttype = node.resulttype;
        }
        if (node.resulttypmod !== undefined) {
            result.resulttypmod = node.resulttypmod;
        }
        if (node.resultcollid !== undefined) {
            result.resultcollid = node.resultcollid;
        }
        if (node.coerceformat !== undefined) {
            result.coerceformat = node.coerceformat;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ArrayCoerceExpr: result };
    }
    ConvertRowtypeExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.resulttype !== undefined) {
            result.resulttype = node.resulttype;
        }
        if (node.convertformat !== undefined) {
            result.convertformat = node.convertformat;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { ConvertRowtypeExpr: result };
    }
    NamedArgExpr(node, context) {
        const result = {};
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.argnumber !== undefined) {
            result.argnumber = node.argnumber;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { NamedArgExpr: result };
    }
    ViewStmt(node, context) {
        const result = {};
        if (node.view !== undefined) {
            result.view = this.transform(node.view, context);
        }
        if (node.aliases !== undefined) {
            result.aliases = Array.isArray(node.aliases)
                ? node.aliases.map((item) => this.transform(item, context))
                : this.transform(node.aliases, context);
        }
        if (node.query !== undefined) {
            result.query = this.transform(node.query, context);
        }
        if (node.replace !== undefined) {
            result.replace = node.replace;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.withCheckOption !== undefined) {
            result.withCheckOption = node.withCheckOption;
        }
        return { ViewStmt: result };
    }
    IndexStmt(node, context) {
        const result = {};
        if (node.idxname !== undefined) {
            result.idxname = node.idxname;
        }
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.accessMethod !== undefined) {
            result.accessMethod = node.accessMethod;
        }
        if (node.tableSpace !== undefined) {
            result.tableSpace = node.tableSpace;
        }
        if (node.indexParams !== undefined) {
            result.indexParams = Array.isArray(node.indexParams)
                ? node.indexParams.map((item) => this.transform(item, context))
                : this.transform(node.indexParams, context);
        }
        if (node.indexIncludingParams !== undefined) {
            result.indexIncludingParams = Array.isArray(node.indexIncludingParams)
                ? node.indexIncludingParams.map((item) => this.transform(item, context))
                : this.transform(node.indexIncludingParams, context);
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        if (node.excludeOpNames !== undefined) {
            result.excludeOpNames = Array.isArray(node.excludeOpNames)
                ? node.excludeOpNames.map((item) => this.transform(item, context))
                : this.transform(node.excludeOpNames, context);
        }
        if (node.idxcomment !== undefined) {
            result.idxcomment = node.idxcomment;
        }
        if (node.indexOid !== undefined) {
            result.indexOid = node.indexOid;
        }
        if (node.oldNode !== undefined) {
            result.oldNode = node.oldNode;
        }
        if (node.oldCreateSubid !== undefined) {
            result.oldCreateSubid = node.oldCreateSubid;
        }
        if (node.oldFirstRelfilenodeSubid !== undefined) {
            result.oldFirstRelfilenodeSubid = node.oldFirstRelfilenodeSubid;
        }
        if (node.unique !== undefined) {
            result.unique = node.unique;
        }
        if (node.nulls_not_distinct !== undefined) {
            result.nulls_not_distinct = node.nulls_not_distinct;
        }
        if (node.primary !== undefined) {
            result.primary = node.primary;
        }
        if (node.isconstraint !== undefined) {
            result.isconstraint = node.isconstraint;
        }
        if (node.deferrable !== undefined) {
            result.deferrable = node.deferrable;
        }
        if (node.initdeferred !== undefined) {
            result.initdeferred = node.initdeferred;
        }
        if (node.transformed !== undefined) {
            result.transformed = node.transformed;
        }
        if (node.concurrent !== undefined) {
            result.concurrent = node.concurrent;
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        if (node.reset_default_tblspc !== undefined) {
            result.reset_default_tblspc = node.reset_default_tblspc;
        }
        return { IndexStmt: result };
    }
    IndexElem(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.expr !== undefined) {
            result.expr = this.transform(node.expr, context);
        }
        if (node.indexcolname !== undefined) {
            result.indexcolname = node.indexcolname;
        }
        if (node.collation !== undefined) {
            result.collation = Array.isArray(node.collation)
                ? node.collation.map((item) => this.transform(item, context))
                : this.transform(node.collation, context);
        }
        if (node.opclass !== undefined) {
            result.opclass = Array.isArray(node.opclass)
                ? node.opclass.map((item) => this.transform(item, context))
                : this.transform(node.opclass, context);
        }
        if (node.opclassopts !== undefined) {
            result.opclassopts = Array.isArray(node.opclassopts)
                ? node.opclassopts.map((item) => this.transform(item, context))
                : this.transform(node.opclassopts, context);
        }
        if (node.ordering !== undefined) {
            result.ordering = node.ordering;
        }
        if (node.nulls_ordering !== undefined) {
            result.nulls_ordering = node.nulls_ordering;
        }
        return { IndexElem: result };
    }
    PartitionElem(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.expr !== undefined) {
            result.expr = this.transform(node.expr, context);
        }
        if (node.collation !== undefined) {
            result.collation = Array.isArray(node.collation)
                ? node.collation.map((item) => this.transform(item, context))
                : this.transform(node.collation, context);
        }
        if (node.opclass !== undefined) {
            result.opclass = Array.isArray(node.opclass)
                ? node.opclass.map((item) => this.transform(item, context))
                : this.transform(node.opclass, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { PartitionElem: result };
    }
    PartitionCmd(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = this.transform(node.name, context);
        }
        if (node.bound !== undefined) {
            result.bound = this.transform(node.bound, context);
        }
        if (node.concurrent !== undefined) {
            result.concurrent = node.concurrent;
        }
        return { PartitionCmd: result };
    }
    JoinExpr(node, context) {
        const result = {};
        if (node.jointype !== undefined) {
            result.jointype = node.jointype;
        }
        if (node.isNatural !== undefined) {
            result.isNatural = node.isNatural;
        }
        if (node.larg !== undefined) {
            result.larg = this.transform(node.larg, context);
        }
        if (node.rarg !== undefined) {
            result.rarg = this.transform(node.rarg, context);
        }
        if (node.usingClause !== undefined) {
            result.usingClause = Array.isArray(node.usingClause)
                ? node.usingClause.map((item) => this.transform(item, context))
                : this.transform(node.usingClause, context);
        }
        if (node.join_using_alias !== undefined) {
            result.join_using_alias = this.transform(node.join_using_alias, context);
        }
        if (node.quals !== undefined) {
            result.quals = this.transform(node.quals, context);
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        if (node.rtindex !== undefined) {
            result.rtindex = node.rtindex;
        }
        return { JoinExpr: result };
    }
    FromExpr(node, context) {
        const result = {};
        if (node.fromlist !== undefined) {
            result.fromlist = Array.isArray(node.fromlist)
                ? node.fromlist.map((item) => this.transform(item, context))
                : this.transform(node.fromlist, context);
        }
        if (node.quals !== undefined) {
            result.quals = this.transform(node.quals, context);
        }
        return { FromExpr: result };
    }
    TransactionStmt(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.savepoint_name !== undefined) {
            result.savepoint_name = node.savepoint_name;
        }
        if (node.gid !== undefined) {
            result.gid = node.gid;
        }
        if (node.chain !== undefined) {
            result.chain = node.chain;
        }
        return { TransactionStmt: result };
    }
    VariableSetStmt(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.is_local !== undefined) {
            result.is_local = node.is_local;
        }
        return { VariableSetStmt: result };
    }
    VariableShowStmt(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        return { VariableShowStmt: result };
    }
    CreateSchemaStmt(node, context) {
        const result = {};
        if (node.schemaname !== undefined) {
            result.schemaname = node.schemaname;
        }
        if (node.authrole !== undefined) {
            result.authrole = this.transform(node.authrole, context);
        }
        if (node.schemaElts !== undefined) {
            result.schemaElts = Array.isArray(node.schemaElts)
                ? node.schemaElts.map((item) => this.transform(item, context))
                : this.transform(node.schemaElts, context);
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        return { CreateSchemaStmt: result };
    }
    RoleSpec(node, context) {
        const result = {};
        if (node.roletype !== undefined) {
            result.roletype = node.roletype;
        }
        if (node.rolename !== undefined) {
            result.rolename = node.rolename;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { RoleSpec: result };
    }
    DropStmt(node, context) {
        const result = {};
        if (node.objects !== undefined) {
            result.objects = Array.isArray(node.objects)
                ? node.objects.map((item) => this.transform(item, context))
                : this.transform(node.objects, context);
        }
        if (node.removeType !== undefined) {
            result.removeType = node.removeType;
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        if (node.concurrent !== undefined) {
            result.concurrent = node.concurrent;
        }
        return { DropStmt: result };
    }
    TruncateStmt(node, context) {
        const result = {};
        if (node.relations !== undefined) {
            result.relations = Array.isArray(node.relations)
                ? node.relations.map((item) => this.transform(item, context))
                : this.transform(node.relations, context);
        }
        if (node.restart_seqs !== undefined) {
            result.restart_seqs = node.restart_seqs;
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        return { TruncateStmt: result };
    }
    ReturnStmt(node, context) {
        const result = {};
        if (node.returnval !== undefined) {
            result.returnval = this.transform(node.returnval, context);
        }
        return { ReturnStmt: result };
    }
    PLAssignStmt(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.indirection !== undefined) {
            result.indirection = Array.isArray(node.indirection)
                ? node.indirection.map((item) => this.transform(item, context))
                : this.transform(node.indirection, context);
        }
        if (node.nnames !== undefined) {
            result.nnames = node.nnames;
        }
        if (node.val !== undefined) {
            result.val = this.transform(node.val, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { PLAssignStmt: result };
    }
    CopyStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.query !== undefined) {
            result.query = this.transform(node.query, context);
        }
        if (node.attlist !== undefined) {
            result.attlist = Array.isArray(node.attlist)
                ? node.attlist.map((item) => this.transform(item, context))
                : this.transform(node.attlist, context);
        }
        if (node.is_from !== undefined) {
            result.is_from = node.is_from;
        }
        if (node.is_program !== undefined) {
            result.is_program = node.is_program;
        }
        if (node.filename !== undefined) {
            result.filename = node.filename;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        return { CopyStmt: result };
    }
    AlterTableStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.cmds !== undefined) {
            result.cmds = Array.isArray(node.cmds)
                ? node.cmds.map((item) => this.transform(item, context))
                : this.transform(node.cmds, context);
        }
        if (node.objtype !== undefined) {
            result.objtype = node.objtype;
        }
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        return { AlterTableStmt: result };
    }
    AlterTableCmd(node, context) {
        const result = {};
        if (node.subtype !== undefined) {
            result.subtype = node.subtype;
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.num !== undefined) {
            result.num = node.num;
        }
        if (node.newowner !== undefined) {
            result.newowner = this.transform(node.newowner, context);
        }
        if (node.def !== undefined) {
            result.def = this.transform(node.def, context);
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        return { AlterTableCmd: result };
    }
    CreateFunctionStmt(node, context) {
        const result = {};
        if (node.is_procedure !== undefined) {
            result.is_procedure = node.is_procedure;
        }
        if (node.replace !== undefined) {
            result.replace = node.replace;
        }
        if (node.funcname !== undefined) {
            result.funcname = Array.isArray(node.funcname)
                ? node.funcname.map((item) => this.transform(item, context))
                : this.transform(node.funcname, context);
        }
        if (node.parameters !== undefined) {
            result.parameters = Array.isArray(node.parameters)
                ? node.parameters.map((item) => this.transform(item, context))
                : this.transform(node.parameters, context);
        }
        if (node.returnType !== undefined) {
            result.returnType = this.transform(node.returnType, context);
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.sql_body !== undefined) {
            result.sql_body = this.transform(node.sql_body, context);
        }
        return { CreateFunctionStmt: result };
    }
    FunctionParameter(node, context) {
        const result = {};
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.argType !== undefined) {
            result.argType = this.transform(node.argType, context);
        }
        if (node.mode !== undefined) {
            result.mode = node.mode;
        }
        if (node.defexpr !== undefined) {
            result.defexpr = this.transform(node.defexpr, context);
        }
        return { FunctionParameter: result };
    }
    CompositeTypeStmt(node, context) {
        const result = {};
        if (node.typevar !== undefined) {
            result.typevar = this.transform(node.typevar, context);
        }
        if (node.coldeflist !== undefined) {
            result.coldeflist = Array.isArray(node.coldeflist)
                ? node.coldeflist.map((item) => this.transform(item, context))
                : this.transform(node.coldeflist, context);
        }
        return { CompositeTypeStmt: result };
    }
    DoStmt(node, context) {
        const result = {};
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        return { DoStmt: result };
    }
    DefineStmt(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.oldstyle !== undefined) {
            result.oldstyle = node.oldstyle;
        }
        if (node.defnames !== undefined) {
            result.defnames = Array.isArray(node.defnames)
                ? node.defnames.map((item) => this.transform(item, context))
                : this.transform(node.defnames, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.definition !== undefined) {
            result.definition = Array.isArray(node.definition)
                ? node.definition.map((item) => this.transform(item, context))
                : this.transform(node.definition, context);
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        if (node.replace !== undefined) {
            result.replace = node.replace;
        }
        return { DefineStmt: result };
    }
    RangeSubselect(node, context) {
        const result = {};
        if (node.lateral !== undefined) {
            result.lateral = node.lateral;
        }
        if (node.subquery !== undefined) {
            result.subquery = this.transform(node.subquery, context);
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        return { RangeSubselect: result };
    }
    CreateEnumStmt(node, context) {
        const result = {};
        if (node.typeName !== undefined) {
            result.typeName = Array.isArray(node.typeName)
                ? node.typeName.map((item) => this.transform(item, context))
                : this.transform(node.typeName, context);
        }
        if (node.vals !== undefined) {
            result.vals = Array.isArray(node.vals)
                ? node.vals.map((item) => this.transform(item, context))
                : this.transform(node.vals, context);
        }
        return { CreateEnumStmt: result };
    }
    CreateDomainStmt(node, context) {
        const result = {};
        if (node.domainname !== undefined) {
            result.domainname = Array.isArray(node.domainname)
                ? node.domainname.map((item) => this.transform(item, context))
                : this.transform(node.domainname, context);
        }
        if (node.typeName !== undefined) {
            result.typeName = this.transform(node.typeName, context);
        }
        if (node.collClause !== undefined) {
            result.collClause = this.transform(node.collClause, context);
        }
        if (node.constraints !== undefined) {
            result.constraints = Array.isArray(node.constraints)
                ? node.constraints.map((item) => this.transform(item, context))
                : this.transform(node.constraints, context);
        }
        return { CreateDomainStmt: result };
    }
    CreateRoleStmt(node, context) {
        const result = {};
        if (node.stmt_type !== undefined) {
            result.stmt_type = node.stmt_type;
        }
        if (node.role !== undefined) {
            result.role = node.role;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        return { CreateRoleStmt: result };
    }
    DefElem(node, context) {
        const result = {};
        if (node.defnamespace !== undefined) {
            result.defnamespace = node.defnamespace;
        }
        if (node.defname !== undefined) {
            result.defname = node.defname;
        }
        if (node.arg !== undefined) {
            result.arg = this.transform(node.arg, context);
        }
        if (node.defaction !== undefined) {
            result.defaction = node.defaction;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { DefElem: result };
    }
    CreateTableSpaceStmt(node, context) {
        const result = {};
        if (node.tablespacename !== undefined) {
            result.tablespacename = node.tablespacename;
        }
        if (node.owner !== undefined) {
            result.owner = this.transform(node.owner, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        return { CreateTableSpaceStmt: result };
    }
    DropTableSpaceStmt(node, context) {
        const result = {};
        if (node.tablespacename !== undefined) {
            result.tablespacename = node.tablespacename;
        }
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        return { DropTableSpaceStmt: result };
    }
    AlterTableSpaceOptionsStmt(node, context) {
        const result = {};
        if (node.tablespacename !== undefined) {
            result.tablespacename = node.tablespacename;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.isReset !== undefined) {
            result.isReset = node.isReset;
        }
        return { AlterTableSpaceOptionsStmt: result };
    }
    CreateExtensionStmt(node, context) {
        const result = {};
        if (node.extname !== undefined) {
            result.extname = node.extname;
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        return { CreateExtensionStmt: result };
    }
    AlterExtensionStmt(node, context) {
        const result = {};
        if (node.extname !== undefined) {
            result.extname = node.extname;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map((item) => this.transform(item, context))
                : this.transform(node.options, context);
        }
        return { AlterExtensionStmt: result };
    }
    CreateFdwStmt(node, context) {
        const result = { ...node };
        return { CreateFdwStmt: result };
    }
    SetOperationStmt(node, context) {
        const result = { ...node };
        return { SetOperationStmt: result };
    }
    ReplicaIdentityStmt(node, context) {
        const result = { ...node };
        return { ReplicaIdentityStmt: result };
    }
    AlterCollationStmt(node, context) {
        const result = { ...node };
        return { AlterCollationStmt: result };
    }
    AlterDomainStmt(node, context) {
        const result = { ...node };
        return { AlterDomainStmt: result };
    }
    PrepareStmt(node, context) {
        const result = { ...node };
        return { PrepareStmt: result };
    }
    ExecuteStmt(node, context) {
        const result = { ...node };
        return { ExecuteStmt: result };
    }
    DeallocateStmt(node, context) {
        const result = { ...node };
        return { DeallocateStmt: result };
    }
    NotifyStmt(node, context) {
        const result = { ...node };
        return { NotifyStmt: result };
    }
    ListenStmt(node, context) {
        const result = { ...node };
        return { ListenStmt: result };
    }
    UnlistenStmt(node, context) {
        const result = { ...node };
        return { UnlistenStmt: result };
    }
    CheckPointStmt(node, context) {
        const result = { ...node };
        return { CheckPointStmt: result };
    }
    LoadStmt(node, context) {
        const result = { ...node };
        return { LoadStmt: result };
    }
    DiscardStmt(node, context) {
        const result = { ...node };
        return { DiscardStmt: result };
    }
    CommentStmt(node, context) {
        const result = {};
        if (node.objtype !== undefined) {
            result.objtype = node.objtype;
        }
        if (node.object !== undefined) {
            result.object = this.transform(node.object, context);
        }
        if (node.comment !== undefined) {
            result.comment = node.comment;
        }
        return { CommentStmt: result };
    }
    LockStmt(node, context) {
        const result = { ...node };
        return { LockStmt: result };
    }
    CreatePolicyStmt(node, context) {
        const result = { ...node };
        return { CreatePolicyStmt: result };
    }
    AlterPolicyStmt(node, context) {
        const result = { ...node };
        return { AlterPolicyStmt: result };
    }
    CreateUserMappingStmt(node, context) {
        const result = { ...node };
        return { CreateUserMappingStmt: result };
    }
    CreateStatsStmt(node, context) {
        const result = { ...node };
        return { CreateStatsStmt: result };
    }
    StatsElem(node, context) {
        const result = { ...node };
        return { StatsElem: result };
    }
    CreatePublicationStmt(node, context) {
        const result = { ...node };
        return { CreatePublicationStmt: result };
    }
    CreateSubscriptionStmt(node, context) {
        const result = { ...node };
        return { CreateSubscriptionStmt: result };
    }
    AlterPublicationStmt(node, context) {
        const result = { ...node };
        return { AlterPublicationStmt: result };
    }
    AlterSubscriptionStmt(node, context) {
        const result = { ...node };
        return { AlterSubscriptionStmt: result };
    }
    DropSubscriptionStmt(node, context) {
        const result = { ...node };
        return { DropSubscriptionStmt: result };
    }
    InlineCodeBlock(node, context) {
        const result = { ...node };
        return { InlineCodeBlock: result };
    }
    CallContext(node, context) {
        const result = { ...node };
        return { CallContext: result };
    }
    ConstraintsSetStmt(node, context) {
        const result = { ...node };
        return { ConstraintsSetStmt: result };
    }
    AlterSystemStmt(node, context) {
        const result = { ...node };
        return { AlterSystemStmt: result };
    }
    VacuumRelation(node, context) {
        const result = { ...node };
        return { VacuumRelation: result };
    }
    DropOwnedStmt(node, context) {
        const result = { ...node };
        return { DropOwnedStmt: result };
    }
    ReassignOwnedStmt(node, context) {
        const result = { ...node };
        return { ReassignOwnedStmt: result };
    }
    AlterTSDictionaryStmt(node, context) {
        const result = { ...node };
        return { AlterTSDictionaryStmt: result };
    }
    AlterTSConfigurationStmt(node, context) {
        const result = { ...node };
        return { AlterTSConfigurationStmt: result };
    }
    ClosePortalStmt(node, context) {
        const result = { ...node };
        return { ClosePortalStmt: result };
    }
    FetchStmt(node, context) {
        const result = { ...node };
        return { FetchStmt: result };
    }
    AlterStatsStmt(node, context) {
        const result = { ...node };
        return { AlterStatsStmt: result };
    }
    ObjectWithArgs(node, context) {
        const result = { ...node };
        return { ObjectWithArgs: result };
    }
    AlterOperatorStmt(node, context) {
        const result = { ...node };
        return { AlterOperatorStmt: result };
    }
    AlterFdwStmt(node, context) {
        const result = { ...node };
        return { AlterFdwStmt: result };
    }
    CreateForeignServerStmt(node, context) {
        const result = { ...node };
        return { CreateForeignServerStmt: result };
    }
    AlterForeignServerStmt(node, context) {
        const result = { ...node };
        return { AlterForeignServerStmt: result };
    }
    AlterUserMappingStmt(node, context) {
        const result = { ...node };
        return { AlterUserMappingStmt: result };
    }
    DropUserMappingStmt(node, context) {
        const result = { ...node };
        return { DropUserMappingStmt: result };
    }
    ImportForeignSchemaStmt(node, context) {
        const result = { ...node };
        return { ImportForeignSchemaStmt: result };
    }
    ClusterStmt(node, context) {
        const result = { ...node };
        return { ClusterStmt: result };
    }
    VacuumStmt(node, context) {
        const result = { ...node };
        return { VacuumStmt: result };
    }
    ExplainStmt(node, context) {
        const result = { ...node };
        return { ExplainStmt: result };
    }
    ReindexStmt(node, context) {
        const result = { ...node };
        return { ReindexStmt: result };
    }
    CallStmt(node, context) {
        const result = { ...node };
        return { CallStmt: result };
    }
    CreatedbStmt(node, context) {
        const result = { ...node };
        return { CreatedbStmt: result };
    }
    DropdbStmt(node, context) {
        const result = { ...node };
        return { DropdbStmt: result };
    }
    RenameStmt(node, context) {
        const result = { ...node };
        return { RenameStmt: result };
    }
    AlterOwnerStmt(node, context) {
        const result = { ...node };
        return { AlterOwnerStmt: result };
    }
    GrantRoleStmt(node, context) {
        const result = {};
        if (node.granted_roles !== undefined) {
            result.granted_roles = Array.isArray(node.granted_roles)
                ? node.granted_roles.map((item) => this.transform(item, context))
                : this.transform(node.granted_roles, context);
        }
        if (node.grantee_roles !== undefined) {
            result.grantee_roles = Array.isArray(node.grantee_roles)
                ? node.grantee_roles.map((item) => this.transform(item, context))
                : this.transform(node.grantee_roles, context);
        }
        if (node.is_grant !== undefined) {
            result.is_grant = node.is_grant;
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        const nodeAny = node;
        if (nodeAny.admin_opt === true) {
            result.opt = [
                {
                    DefElem: {
                        defname: "admin",
                        arg: {
                            Boolean: {
                                boolval: true
                            }
                        },
                        defaction: "DEFELEM_UNSPEC"
                    }
                }
            ];
        }
        else if (nodeAny.opt !== undefined) {
            // Handle any existing opt field by transforming it
            result.opt = Array.isArray(nodeAny.opt)
                ? nodeAny.opt.map((item) => this.transform(item, context))
                : this.transform(nodeAny.opt, context);
        }
        return { GrantRoleStmt: result };
    }
    SecLabelStmt(node, context) {
        const result = { ...node };
        return { SecLabelStmt: result };
    }
    AlterDefaultPrivilegesStmt(node, context) {
        const result = { ...node };
        return { AlterDefaultPrivilegesStmt: result };
    }
    CreateConversionStmt(node, context) {
        const result = { ...node };
        return { CreateConversionStmt: result };
    }
    CreateCastStmt(node, context) {
        const result = { ...node };
        return { CreateCastStmt: result };
    }
    CreatePLangStmt(node, context) {
        const result = { ...node };
        return { CreatePLangStmt: result };
    }
    CreateTransformStmt(node, context) {
        const result = { ...node };
        return { CreateTransformStmt: result };
    }
    CreateTrigStmt(node, context) {
        const result = { ...node };
        return { CreateTrigStmt: result };
    }
    TriggerTransition(node, context) {
        const result = { ...node };
        return { TriggerTransition: result };
    }
    CreateEventTrigStmt(node, context) {
        const result = { ...node };
        return { CreateEventTrigStmt: result };
    }
    AlterEventTrigStmt(node, context) {
        const result = { ...node };
        return { AlterEventTrigStmt: result };
    }
    CreateOpClassStmt(node, context) {
        const result = { ...node };
        return { CreateOpClassStmt: result };
    }
    CreateOpFamilyStmt(node, context) {
        const result = { ...node };
        return { CreateOpFamilyStmt: result };
    }
    AlterOpFamilyStmt(node, context) {
        const result = { ...node };
        return { AlterOpFamilyStmt: result };
    }
    MergeStmt(node, context) {
        const result = { ...node };
        return { MergeStmt: result };
    }
    AlterTableMoveAllStmt(node, context) {
        const result = { ...node };
        return { AlterTableMoveAllStmt: result };
    }
    CreateSeqStmt(node, context) {
        const result = { ...node };
        return { CreateSeqStmt: result };
    }
    AlterSeqStmt(node, context) {
        const result = { ...node };
        return { AlterSeqStmt: result };
    }
    CreateRangeStmt(node, context) {
        const result = {};
        if (node.typeName !== undefined) {
            result.typeName = Array.isArray(node.typeName)
                ? node.typeName.map((item) => this.transform(item, context))
                : this.transform(node.typeName, context);
        }
        if (node.params !== undefined) {
            result.params = Array.isArray(node.params)
                ? node.params.map((item) => this.transform(item, context))
                : this.transform(node.params, context);
        }
        return { CreateRangeStmt: result };
    }
    AlterEnumStmt(node, context) {
        const result = { ...node };
        return { AlterEnumStmt: result };
    }
    AlterTypeStmt(node, context) {
        const result = { ...node };
        return { AlterTypeStmt: result };
    }
    AlterRoleStmt(node, context) {
        const result = { ...node };
        return { AlterRoleStmt: result };
    }
    CreateTableAsStmt(node, context) {
        const result = { ...node };
        return { CreateTableAsStmt: result };
    }
    RefreshMatViewStmt(node, context) {
        const result = { ...node };
        return { RefreshMatViewStmt: result };
    }
    AccessPriv(node, context) {
        const result = { ...node };
        return { AccessPriv: result };
    }
    AlterDatabaseStmt(node, context) {
        const result = { ...node };
        return { AlterDatabaseStmt: result };
    }
    AlterDatabaseRefreshCollStmt(node, context) {
        const result = { ...node };
        return { AlterDatabaseRefreshCollStmt: result };
    }
    AlterDatabaseSetStmt(node, context) {
        const result = { ...node };
        return { AlterDatabaseSetStmt: result };
    }
    DeclareCursorStmt(node, context) {
        const result = { ...node };
        return { DeclareCursorStmt: result };
    }
    PublicationObjSpec(node, context) {
        const result = { ...node };
        return { PublicationObjSpec: result };
    }
    PublicationTable(node, context) {
        const result = { ...node };
        return { PublicationTable: result };
    }
    CreateAmStmt(node, context) {
        const result = { ...node };
        return { CreateAmStmt: result };
    }
    IntoClause(node, context) {
        const result = { ...node };
        return { IntoClause: result };
    }
    OnConflictExpr(node, context) {
        const result = { ...node };
        return { OnConflictExpr: result };
    }
    ScanToken(node, context) {
        const result = { ...node };
        return { ScanToken: result };
    }
    CreateOpClassItem(node, context) {
        const result = { ...node };
        return { CreateOpClassItem: result };
    }
    Var(node, context) {
        const result = { ...node };
        return { Var: result };
    }
    TableFunc(node, context) {
        const result = { ...node };
        return { TableFunc: result };
    }
    RangeTableFunc(node, context) {
        const result = { ...node };
        return { RangeTableFunc: result };
    }
    RangeTableFuncCol(node, context) {
        const result = { ...node };
        return { RangeTableFuncCol: result };
    }
    RangeFunction(node, context) {
        const result = { ...node };
        if (node.lateral !== undefined) {
            result.lateral = node.lateral;
        }
        if (node.ordinality !== undefined) {
            result.ordinality = node.ordinality;
        }
        if (node.is_rowsfrom !== undefined) {
            result.is_rowsfrom = node.is_rowsfrom;
        }
        if (node.functions !== undefined) {
            result.functions = Array.isArray(node.functions)
                ? node.functions.map((item) => this.transform(item, context))
                : this.transform(node.functions, context);
        }
        if (node.alias !== undefined) {
            result.alias = this.transform(node.alias, context);
        }
        if (node.coldeflist !== undefined) {
            result.coldeflist = Array.isArray(node.coldeflist)
                ? node.coldeflist.map((item) => this.transform(item, context))
                : this.transform(node.coldeflist, context);
        }
        return { RangeFunction: result };
    }
    RangeTableSample(node, context) {
        const result = { ...node };
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.method !== undefined) {
            result.method = Array.isArray(node.method)
                ? node.method.map((item) => this.transform(item, context))
                : this.transform(node.method, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.repeatable !== undefined) {
            result.repeatable = this.transform(node.repeatable, context);
        }
        return { RangeTableSample: result };
    }
    XmlSerialize(node, context) {
        const result = { ...node };
        if (node.xmloption !== undefined) {
            result.xmloption = node.xmloption;
        }
        if (node.expr !== undefined) {
            result.expr = this.transform(node.expr, context);
        }
        if (node.typeName !== undefined) {
            result.typeName = this.transform(node.typeName, context);
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { XmlSerialize: result };
    }
    RuleStmt(node, context) {
        const result = { ...node };
        return { RuleStmt: result };
    }
    SQLValueFunction(node, context) {
        const result = { ...node };
        return { SQLValueFunction: result };
    }
    GroupingFunc(node, context) {
        const result = { ...node };
        return { GroupingFunc: result };
    }
    MultiAssignRef(node, context) {
        const result = { ...node };
        return { MultiAssignRef: result };
    }
    SetToDefault(node, context) {
        const result = { ...node };
        return { SetToDefault: result };
    }
    CurrentOfExpr(node, context) {
        const result = { ...node };
        return { CurrentOfExpr: result };
    }
    TableLikeClause(node, context) {
        const result = { ...node };
        return { TableLikeClause: result };
    }
    AlterFunctionStmt(node, context) {
        const result = { ...node };
        return { AlterFunctionStmt: result };
    }
    AlterObjectSchemaStmt(node, context) {
        const result = { ...node };
        return { AlterObjectSchemaStmt: result };
    }
    CreateForeignTableStmt(node, context) {
        const result = { ...node };
        return { CreateForeignTableStmt: result };
    }
    DropRoleStmt(node, context) {
        const result = { ...node };
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        if (node.roles !== undefined) {
            result.roles = Array.isArray(node.roles)
                ? node.roles.map((item) => this.transform(item, context))
                : this.transform(node.roles, context);
        }
        return { DropRoleStmt: result };
    }
    XmlExpr(node, context) {
        const result = { ...node };
        if (node.xpr !== undefined) {
            result.xpr = this.transform(node.xpr, context);
        }
        if (node.op !== undefined) {
            result.op = node.op;
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.named_args !== undefined) {
            result.named_args = Array.isArray(node.named_args)
                ? node.named_args.map((item) => this.transform(item, context))
                : this.transform(node.named_args, context);
        }
        if (node.arg_names !== undefined) {
            result.arg_names = Array.isArray(node.arg_names)
                ? node.arg_names.map((item) => this.transform(item, context))
                : this.transform(node.arg_names, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map((item) => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.xmloption !== undefined) {
            result.xmloption = node.xmloption;
        }
        if (node.type !== undefined) {
            result.type = node.type;
        }
        if (node.typmod !== undefined) {
            result.typmod = node.typmod;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { XmlExpr: result };
    }
    AlterRoleSetStmt(node, context) {
        const result = { ...node };
        if (node.role !== undefined) {
            result.role = this.transform(node.role, context);
        }
        if (node.database !== undefined) {
            result.database = node.database;
        }
        if (node.setstmt !== undefined) {
            result.setstmt = this.transform(node.setstmt, context);
        }
        return { AlterRoleSetStmt: result };
    }
    GrantStmt(node, context) {
        const result = { ...node };
        if (node.is_grant !== undefined) {
            result.is_grant = node.is_grant;
        }
        if (node.targtype !== undefined) {
            result.targtype = node.targtype;
        }
        if (node.objtype !== undefined) {
            result.objtype = node.objtype;
        }
        if (node.objects !== undefined) {
            result.objects = Array.isArray(node.objects)
                ? node.objects.map((item) => this.transform(item, context))
                : this.transform(node.objects, context);
        }
        if (node.privileges !== undefined) {
            result.privileges = Array.isArray(node.privileges)
                ? node.privileges.map((item) => this.transform(item, context))
                : this.transform(node.privileges, context);
        }
        if (node.grantees !== undefined) {
            result.grantees = Array.isArray(node.grantees)
                ? node.grantees.map((item) => this.transform(item, context))
                : this.transform(node.grantees, context);
        }
        if (node.grant_option !== undefined) {
            result.grant_option = node.grant_option;
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        return { GrantStmt: result };
    }
}
