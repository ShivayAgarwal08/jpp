"use strict";
/**
 * Auto-generated file with types stripped for better tree-shaking
 * DO NOT EDIT - Generated by strip-transformer-types.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.V14ToV15Transformer = void 0;
// @ts-nocheck
/**
 * V14 to V15 AST Transformer
 * Transforms PostgreSQL v14 AST nodes to v15 format
 */
class V14ToV15Transformer {
    transform(node, context = { parentNodeTypes: [] }) {
        if (node == null) {
            return null;
        }
        if (typeof node === 'number' || node instanceof Number) {
            return node;
        }
        if (typeof node === 'string') {
            return node;
        }
        try {
            return this.visit(node, context);
        }
        catch (error) {
            const nodeType = Object.keys(node)[0];
            throw new Error(`Error transforming ${nodeType}: ${error.message}`);
        }
    }
    visit(node, context = { parentNodeTypes: [] }) {
        const nodeType = this.getNodeType(node);
        // Handle empty objects
        if (!nodeType) {
            return {};
        }
        const nodeData = this.getNodeData(node);
        const methodName = nodeType;
        if (typeof this[methodName] === 'function') {
            const childContext = {
                ...context,
                parentNodeTypes: [...context.parentNodeTypes, nodeType]
            };
            const result = this[methodName](nodeData, childContext);
            return result;
        }
        // If no specific method, use transformGenericNode to handle nested transformations
        return this.transformGenericNode(node, context);
    }
    getNodeType(node) {
        return Object.keys(node)[0];
    }
    getNodeData(node) {
        const keys = Object.keys(node);
        if (keys.length === 1 && typeof node[keys[0]] === 'object') {
            return node[keys[0]];
        }
        return node;
    }
    transformGenericNode(node, context) {
        if (typeof node !== 'object' || node === null)
            return node;
        if (Array.isArray(node))
            return node.map(item => this.transform(item, context));
        const keys = Object.keys(node);
        if (keys.length === 1 && typeof node[keys[0]] === 'object' && node[keys[0]] !== null && !Array.isArray(node[keys[0]])) {
            const nodeType = keys[0];
            const nodeData = node[keys[0]];
            const transformedData = {};
            for (const [key, value] of Object.entries(nodeData)) {
                if (Array.isArray(value)) {
                    if (key === 'arrayBounds') {
                        transformedData[key] = value.map(item => {
                            return this.transform(item, context);
                        });
                    }
                    else {
                        transformedData[key] = value.map(item => this.transform(item, context));
                    }
                }
                else if (typeof value === 'object' && value !== null) {
                    const keys = Object.keys(value);
                    const isNumericKeysObject = keys.every(k => /^\d+$/.test(k));
                    if (isNumericKeysObject && keys.length > 0) {
                        const sortedKeys = keys.sort((a, b) => parseInt(a) - parseInt(b));
                        transformedData[key] = sortedKeys.map(k => this.transform(value[k], context));
                    }
                    else {
                        // Regular object transformation
                        transformedData[key] = this.transform(value, context);
                    }
                }
                else {
                    transformedData[key] = value;
                }
            }
            return { [nodeType]: transformedData };
        }
        const result = {};
        for (const [key, value] of Object.entries(node)) {
            if (Array.isArray(value)) {
                if (key === 'arrayBounds') {
                    result[key] = value.map(item => {
                        return this.transform(item, context);
                    });
                }
                else {
                    result[key] = value.map(item => this.transform(item, context));
                }
            }
            else if (typeof value === 'object' && value !== null) {
                const keys = Object.keys(value);
                const isNumericKeysObject = keys.every(k => /^\d+$/.test(k));
                if (isNumericKeysObject && keys.length > 0) {
                    const sortedKeys = keys.sort((a, b) => parseInt(a) - parseInt(b));
                    result[key] = sortedKeys.map(k => this.transform(value[k], context));
                }
                else {
                    // Regular object transformation
                    result[key] = this.transform(value, context);
                }
            }
            else {
                result[key] = value;
            }
        }
        return result;
    }
    ParseResult(node, context) {
        if (node && typeof node === 'object' && 'version' in node && 'stmts' in node) {
            return {
                version: 150000, // PG15 version
                stmts: node.stmts.map((stmt) => {
                    if (stmt && typeof stmt === 'object' && 'stmt' in stmt) {
                        return {
                            ...stmt,
                            stmt: this.transform(stmt.stmt, context)
                        };
                    }
                    return this.transform(stmt, context);
                })
            };
        }
        return node;
    }
    RawStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RawStmt: result };
    }
    SelectStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SelectStmt: result };
    }
    A_Expr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { A_Expr: result };
    }
    InsertStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { InsertStmt: result };
    }
    UpdateStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { UpdateStmt: result };
    }
    DeleteStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DeleteStmt: result };
    }
    WithClause(node, context) {
        const result = this.transformGenericNode(node, context);
        return { WithClause: result };
    }
    ResTarget(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ResTarget: result };
    }
    BoolExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { BoolExpr: result };
    }
    FuncCall(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FuncCall: result };
    }
    FuncExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FuncExpr: result };
    }
    A_Const(node, context) {
        const result = {};
        for (const [key, value] of Object.entries(node)) {
            result[key] = value;
        }
        if (result.val) {
            const val = result.val;
            if (val.String && val.String.str !== undefined) {
                result.sval = { sval: val.String.str };
                delete result.val;
            }
            else if (val.Integer !== undefined) {
                if (val.Integer.ival !== undefined) {
                    if (val.Integer.ival === 0) {
                        result.ival = {};
                    }
                    else {
                        result.ival = { ival: val.Integer.ival };
                    }
                }
                else {
                    result.ival = {};
                }
                delete result.val;
            }
            else if (val.Float && val.Float.str !== undefined) {
                result.fval = { fval: val.Float.str };
                delete result.val;
            }
            else if (val.BitString && val.BitString.str !== undefined) {
                result.bsval = { bsval: val.BitString.str };
                delete result.val;
            }
            else if (val.Null !== undefined) {
                result.isnull = true;
                delete result.val;
            }
        }
        // Handle ival field directly (not nested in val) - removed overly broad conversion
        return { A_Const: result };
    }
    ColumnRef(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ColumnRef: result };
    }
    TypeName(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TypeName: result };
    }
    Alias(node, context) {
        const result = this.transformGenericNode(node, context);
        return { Alias: result };
    }
    RangeVar(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeVar: result };
    }
    A_ArrayExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { A_ArrayExpr: result };
    }
    A_Indices(node, context) {
        const result = {};
        if (node.is_slice !== undefined) {
            result.is_slice = node.is_slice;
        }
        if (node.lidx !== undefined) {
            result.lidx = this.transform(node.lidx, context);
        }
        if (node.uidx !== undefined) {
            const childContext = {
                ...context,
                parentNodeTypes: [...(context.parentNodeTypes || []), 'A_Indices']
            };
            result.uidx = this.transform(node.uidx, childContext);
        }
        return { A_Indices: result };
    }
    A_Indirection(node, context) {
        const result = this.transformGenericNode(node, context);
        return { A_Indirection: result };
    }
    A_Star(node, context) {
        const result = this.transformGenericNode(node, context);
        return { A_Star: result };
    }
    CaseExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CaseExpr: result };
    }
    CoalesceExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CoalesceExpr: result };
    }
    TypeCast(node, context) {
        if (node.location === -1 && node.typeName && node.typeName.names) {
            const typeNames = node.typeName.names.map(name => {
                if (name && typeof name === 'object' && 'String' in name) {
                    const stringVal = name.String;
                    return stringVal.sval || stringVal.str;
                }
                return null;
            }).filter(Boolean);
            const hasPgCatalog = typeNames.includes('pg_catalog');
            const hasBool = typeNames.includes('bool');
            if (hasPgCatalog && hasBool && node.arg) {
                const arg = node.arg;
                if (arg.A_Const) {
                    let stringValue = null;
                    // Handle both sval and val.String formats
                    if (arg.A_Const.sval && arg.A_Const.sval.sval) {
                        stringValue = arg.A_Const.sval.sval;
                    }
                    else if (arg.A_Const.val && arg.A_Const.val.String) {
                        if (arg.A_Const.val.String.sval) {
                            stringValue = arg.A_Const.val.String.sval;
                        }
                        else if (arg.A_Const.val.String.str) {
                            stringValue = arg.A_Const.val.String.str;
                        }
                    }
                    if (stringValue === 't' || stringValue === 'true') {
                        return {
                            A_Const: {
                                boolval: { boolval: true },
                                location: arg.A_Const.location
                            }
                        };
                    }
                    else if (stringValue === 'f' || stringValue === 'false') {
                        return {
                            A_Const: {
                                boolval: {},
                                location: arg.A_Const.location
                            }
                        };
                    }
                }
            }
        }
        const result = this.transformGenericNode(node, context);
        return { TypeCast: result };
    }
    CollateClause(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CollateClause: result };
    }
    BooleanTest(node, context) {
        const result = this.transformGenericNode(node, context);
        return { BooleanTest: result };
    }
    NullTest(node, context) {
        const result = this.transformGenericNode(node, context);
        return { NullTest: result };
    }
    String(node, context) {
        const result = { ...node };
        if (result.str !== undefined) {
            result.sval = result.str;
            delete result.str;
        }
        return { String: result };
    }
    Integer(node, context) {
        const isInDefElemContext = context.parentNodeTypes?.includes('DefElem');
        if (isInDefElemContext && node.ival !== undefined) {
            const defElemName = context.defElemName;
            // CreateRoleStmt: specific role attributes should become Boolean
            if (defElemName && ['createrole', 'superuser', 'canlogin', 'createdb', 'inherit', 'bypassrls', 'isreplication'].includes(defElemName) &&
                (node.ival === 0 || node.ival === 1)) {
                return {
                    Boolean: {
                        boolval: node.ival === 1
                    }
                };
            }
            // CreateExtensionStmt: cascade should become Boolean
            if (context.parentNodeTypes?.includes('CreateExtensionStmt') && defElemName) {
                if (defElemName === 'cascade' && (node.ival === 0 || node.ival === 1)) {
                    return {
                        Boolean: {
                            boolval: node.ival === 1
                        }
                    };
                }
            }
            // CreateFunctionStmt: window should become Boolean
            if (context.parentNodeTypes?.includes('CreateFunctionStmt') && defElemName) {
                if (defElemName === 'window' && (node.ival === 0 || node.ival === 1)) {
                    return {
                        Boolean: {
                            boolval: node.ival === 1
                        }
                    };
                }
            }
            if (['strict', 'security', 'leakproof', 'cycle'].includes(defElemName) && (node.ival === 0 || node.ival === 1)) {
                return {
                    Boolean: {
                        boolval: node.ival === 1
                    }
                };
            }
        }
        // AlterTableCmd context: SET STATISTICS with ival 0 or -1 -> empty Integer
        if (context.parentNodeTypes?.includes('AlterTableCmd') && !context.parentNodeTypes?.includes('DefineStmt') && (node.ival === 0)) {
            return { Integer: {} };
        }
        // DefineStmt context: specific cases where ival should become empty Integer
        if (context.parentNodeTypes?.includes('DefineStmt')) {
            const defElemName = context.defElemName;
            if (defElemName === 'initcond' && (node.ival === 0)) {
                return { Integer: {} };
            }
            if (defElemName === 'sspace' && node.ival === 0) {
                return { Integer: {} };
            }
            // DefineStmt args context: ival 0 should become empty Integer for aggregates
            if (!defElemName && (node.ival === 0)) {
                return { Integer: {} };
            }
        }
        // CreateSeqStmt context: specific cases where ival should become empty Integer
        if (context.parentNodeTypes?.includes('CreateSeqStmt')) {
            const defElemName = context.defElemName;
            if (defElemName === 'start' && node.ival === 0) {
                return { Integer: {} };
            }
            if (defElemName === 'minvalue' && node.ival === 0) {
                return { Integer: {} };
            }
            if (defElemName === 'increment' && node.ival === 0) {
                return { Integer: {} };
            }
        }
        const result = { ...node };
        return { Integer: result };
    }
    Float(node, context) {
        const result = { ...node };
        if (result.str !== undefined) {
            result.fval = result.str;
            delete result.str;
        }
        return { Float: result };
    }
    BitString(node, context) {
        const result = { ...node };
        if (result.str !== undefined) {
            result.bsval = result.str;
            delete result.str;
        }
        return { BitString: result };
    }
    // NOTE: there is no Null type in PG15
    Null(node, context) {
        const result = this.transformGenericNode(node, context);
        return { Null: result };
    }
    List(node, context) {
        const result = this.transformGenericNode(node, context);
        return { List: result };
    }
    CreateStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateStmt: result };
    }
    ColumnDef(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ColumnDef: result };
    }
    Constraint(node, context) {
        const result = this.transformGenericNode(node, context);
        return { Constraint: result };
    }
    SubLink(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SubLink: result };
    }
    CaseWhen(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CaseWhen: result };
    }
    WindowDef(node, context) {
        const result = this.transformGenericNode(node, context);
        return { WindowDef: result };
    }
    SortBy(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SortBy: result };
    }
    GroupingSet(node, context) {
        const result = this.transformGenericNode(node, context);
        return { GroupingSet: result };
    }
    CommonTableExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CommonTableExpr: result };
    }
    ParamRef(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ParamRef: result };
    }
    LockingClause(node, context) {
        const result = this.transformGenericNode(node, context);
        return { LockingClause: result };
    }
    MinMaxExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { MinMaxExpr: result };
    }
    RowExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RowExpr: result };
    }
    OpExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { OpExpr: result };
    }
    DistinctExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DistinctExpr: result };
    }
    NullIfExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { NullIfExpr: result };
    }
    ScalarArrayOpExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ScalarArrayOpExpr: result };
    }
    Aggref(node, context) {
        const result = this.transformGenericNode(node, context);
        return { Aggref: result };
    }
    WindowFunc(node, context) {
        const result = this.transformGenericNode(node, context);
        return { WindowFunc: result };
    }
    FieldSelect(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FieldSelect: result };
    }
    RelabelType(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RelabelType: result };
    }
    CoerceViaIO(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CoerceViaIO: result };
    }
    ArrayCoerceExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ArrayCoerceExpr: result };
    }
    ConvertRowtypeExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ConvertRowtypeExpr: result };
    }
    NamedArgExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { NamedArgExpr: result };
    }
    ViewStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ViewStmt: result };
    }
    IndexStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { IndexStmt: result };
    }
    IndexElem(node, context) {
        const result = this.transformGenericNode(node, context);
        return { IndexElem: result };
    }
    PartitionElem(node, context) {
        const result = this.transformGenericNode(node, context);
        return { PartitionElem: result };
    }
    PartitionCmd(node, context) {
        const result = this.transformGenericNode(node, context);
        return { PartitionCmd: result };
    }
    JoinExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { JoinExpr: result };
    }
    FromExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FromExpr: result };
    }
    TransactionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TransactionStmt: result };
    }
    VariableSetStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { VariableSetStmt: result };
    }
    VariableShowStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { VariableShowStmt: result };
    }
    CreateSchemaStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateSchemaStmt: result };
    }
    RoleSpec(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RoleSpec: result };
    }
    DropStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropStmt: result };
    }
    TruncateStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TruncateStmt: result };
    }
    ReturnStmt(node, context) {
        const result = {};
        if (node.returnval !== undefined) {
            result.returnval = this.transform(node.returnval, context);
        }
        return { ReturnStmt: result };
    }
    PLAssignStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { PLAssignStmt: result };
    }
    CopyStmt(node, context) {
        const result = {};
        if (node.relation !== undefined) {
            result.relation = this.transform(node.relation, context);
        }
        if (node.query !== undefined) {
            result.query = this.transform(node.query, context);
        }
        if (node.attlist !== undefined) {
            result.attlist = Array.isArray(node.attlist)
                ? node.attlist.map(item => this.transform(item, context))
                : this.transform(node.attlist, context);
        }
        if (node.is_from !== undefined) {
            result.is_from = node.is_from;
        }
        if (node.is_program !== undefined) {
            result.is_program = node.is_program;
        }
        if (node.filename !== undefined) {
            result.filename = node.filename;
        }
        if (node.options !== undefined) {
            result.options = Array.isArray(node.options)
                ? node.options.map(item => this.transform(item, context))
                : this.transform(node.options, context);
        }
        if (node.whereClause !== undefined) {
            result.whereClause = this.transform(node.whereClause, context);
        }
        return { CopyStmt: result };
    }
    AlterTableStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTableStmt: result };
    }
    AlterTableCmd(node, context) {
        const result = {};
        if (node.subtype !== undefined) {
            result.subtype = node.subtype;
        }
        if (node.name !== undefined) {
            result.name = node.name;
        }
        if (node.num !== undefined) {
            result.num = node.num;
        }
        if (node.newowner !== undefined) {
            result.newowner = this.transform(node.newowner, context);
        }
        if (node.def !== undefined) {
            result.def = this.transform(node.def, context);
        }
        if (node.behavior !== undefined) {
            result.behavior = node.behavior;
        }
        if (node.missing_ok !== undefined) {
            result.missing_ok = node.missing_ok;
        }
        return { AlterTableCmd: result };
    }
    CreateFunctionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateFunctionStmt: result };
    }
    FunctionParameter(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FunctionParameter: result };
    }
    CompositeTypeStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CompositeTypeStmt: result };
    }
    CreateEnumStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateEnumStmt: result };
    }
    CreateDomainStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateDomainStmt: result };
    }
    CreateRoleStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateRoleStmt: result };
    }
    DefElem(node, context) {
        const result = {};
        if (node.defnamespace !== undefined) {
            result.defnamespace = node.defnamespace;
        }
        if (node.defname !== undefined) {
            result.defname = node.defname;
        }
        if (node.arg !== undefined) {
            const argContext = {
                ...context,
                defElemName: node.defname,
                parentNodeTypes: [...(context.parentNodeTypes || []), 'DefElem']
            };
            result.arg = this.transform(node.arg, argContext);
        }
        if (node.defaction !== undefined) {
            result.defaction = node.defaction;
        }
        if (node.location !== undefined) {
            result.location = node.location;
        }
        return { DefElem: result };
    }
    CreateTableSpaceStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateTableSpaceStmt: result };
    }
    DropTableSpaceStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropTableSpaceStmt: result };
    }
    AlterTableSpaceOptionsStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTableSpaceOptionsStmt: result };
    }
    CreateExtensionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateExtensionStmt: result };
    }
    AlterExtensionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterExtensionStmt: result };
    }
    CreateFdwStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateFdwStmt: result };
    }
    SetOperationStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SetOperationStmt: result };
    }
    ReplicaIdentityStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ReplicaIdentityStmt: result };
    }
    AlterCollationStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterCollationStmt: result };
    }
    AlterDomainStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterDomainStmt: result };
    }
    PrepareStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { PrepareStmt: result };
    }
    ExecuteStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ExecuteStmt: result };
    }
    DeallocateStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DeallocateStmt: result };
    }
    NotifyStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { NotifyStmt: result };
    }
    ListenStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ListenStmt: result };
    }
    UnlistenStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { UnlistenStmt: result };
    }
    CheckPointStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CheckPointStmt: result };
    }
    LoadStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { LoadStmt: result };
    }
    DiscardStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DiscardStmt: result };
    }
    CommentStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CommentStmt: result };
    }
    LockStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { LockStmt: result };
    }
    CreatePolicyStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreatePolicyStmt: result };
    }
    AlterPolicyStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterPolicyStmt: result };
    }
    CreateUserMappingStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateUserMappingStmt: result };
    }
    CreateStatsStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateStatsStmt: result };
    }
    StatsElem(node, context) {
        const result = this.transformGenericNode(node, context);
        return { StatsElem: result };
    }
    CreatePublicationStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreatePublicationStmt: result };
    }
    CreateSubscriptionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateSubscriptionStmt: result };
    }
    AlterPublicationStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterPublicationStmt: result };
    }
    AlterSubscriptionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterSubscriptionStmt: result };
    }
    DropSubscriptionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropSubscriptionStmt: result };
    }
    DoStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DoStmt: result };
    }
    InlineCodeBlock(node, context) {
        const result = this.transformGenericNode(node, context);
        return { InlineCodeBlock: result };
    }
    CallContext(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CallContext: result };
    }
    ConstraintsSetStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ConstraintsSetStmt: result };
    }
    AlterSystemStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterSystemStmt: result };
    }
    VacuumRelation(node, context) {
        const result = this.transformGenericNode(node, context);
        return { VacuumRelation: result };
    }
    DropOwnedStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropOwnedStmt: result };
    }
    ReassignOwnedStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ReassignOwnedStmt: result };
    }
    AlterTSDictionaryStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTSDictionaryStmt: result };
    }
    AlterTSConfigurationStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTSConfigurationStmt: result };
    }
    ClosePortalStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ClosePortalStmt: result };
    }
    FetchStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { FetchStmt: result };
    }
    AlterStatsStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterStatsStmt: result };
    }
    ObjectWithArgs(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ObjectWithArgs: result };
    }
    AlterOperatorStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterOperatorStmt: result };
    }
    AlterFdwStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterFdwStmt: result };
    }
    CreateForeignServerStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateForeignServerStmt: result };
    }
    AlterForeignServerStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterForeignServerStmt: result };
    }
    AlterUserMappingStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterUserMappingStmt: result };
    }
    DropUserMappingStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropUserMappingStmt: result };
    }
    ImportForeignSchemaStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ImportForeignSchemaStmt: result };
    }
    ClusterStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ClusterStmt: result };
    }
    VacuumStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { VacuumStmt: result };
    }
    ExplainStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ExplainStmt: result };
    }
    ReindexStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ReindexStmt: result };
    }
    CallStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CallStmt: result };
    }
    CreatedbStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreatedbStmt: result };
    }
    DropdbStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropdbStmt: result };
    }
    RenameStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RenameStmt: result };
    }
    AlterOwnerStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterOwnerStmt: result };
    }
    GrantStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { GrantStmt: result };
    }
    GrantRoleStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { GrantRoleStmt: result };
    }
    SecLabelStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SecLabelStmt: result };
    }
    AlterDefaultPrivilegesStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterDefaultPrivilegesStmt: result };
    }
    CreateConversionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateConversionStmt: result };
    }
    CreateCastStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateCastStmt: result };
    }
    CreatePLangStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreatePLangStmt: result };
    }
    CreateTransformStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateTransformStmt: result };
    }
    CreateTrigStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateTrigStmt: result };
    }
    TriggerTransition(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TriggerTransition: result };
    }
    CreateEventTrigStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateEventTrigStmt: result };
    }
    AlterEventTrigStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterEventTrigStmt: result };
    }
    CreateOpClassStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateOpClassStmt: result };
    }
    CreateOpFamilyStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateOpFamilyStmt: result };
    }
    AlterOpFamilyStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterOpFamilyStmt: result };
    }
    AlterTableMoveAllStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTableMoveAllStmt: result };
    }
    CreateSeqStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateSeqStmt: result };
    }
    AlterSeqStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterSeqStmt: result };
    }
    CreateRangeStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateRangeStmt: result };
    }
    AlterEnumStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterEnumStmt: result };
    }
    AlterTypeStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterTypeStmt: result };
    }
    AlterRoleStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterRoleStmt: result };
    }
    DropRoleStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DropRoleStmt: result };
    }
    CreateTableAsStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateTableAsStmt: result };
    }
    RefreshMatViewStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RefreshMatViewStmt: result };
    }
    AccessPriv(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AccessPriv: result };
    }
    DefineStmt(node, context) {
        const result = {};
        if (node.kind !== undefined) {
            result.kind = node.kind;
        }
        if (node.oldstyle !== undefined) {
            result.oldstyle = node.oldstyle;
        }
        if (node.defnames !== undefined) {
            result.defnames = Array.isArray(node.defnames)
                ? node.defnames.map(item => this.transform(item, context))
                : this.transform(node.defnames, context);
        }
        if (node.args !== undefined) {
            result.args = Array.isArray(node.args)
                ? node.args.map(item => this.transform(item, context))
                : this.transform(node.args, context);
        }
        if (node.definition !== undefined) {
            result.definition = Array.isArray(node.definition)
                ? node.definition.map(item => this.transform(item, context))
                : this.transform(node.definition, context);
        }
        if (node.if_not_exists !== undefined) {
            result.if_not_exists = node.if_not_exists;
        }
        if (node.replace !== undefined) {
            result.replace = node.replace;
        }
        return { DefineStmt: result };
    }
    AlterDatabaseStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterDatabaseStmt: result };
    }
    AlterDatabaseSetStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterDatabaseSetStmt: result };
    }
    DeclareCursorStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { DeclareCursorStmt: result };
    }
    CreateAmStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateAmStmt: result };
    }
    IntoClause(node, context) {
        const result = this.transformGenericNode(node, context);
        return { IntoClause: result };
    }
    OnConflictExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { OnConflictExpr: result };
    }
    ScanToken(node, context) {
        const result = this.transformGenericNode(node, context);
        return { ScanToken: result };
    }
    CreateOpClassItem(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateOpClassItem: result };
    }
    Var(node, context) {
        const result = this.transformGenericNode(node, context);
        return { Var: result };
    }
    TableFunc(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TableFunc: result };
    }
    RangeTableFunc(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeTableFunc: result };
    }
    RangeTableFuncCol(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeTableFuncCol: result };
    }
    RangeFunction(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeFunction: result };
    }
    XmlExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { XmlExpr: result };
    }
    RangeTableSample(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeTableSample: result };
    }
    XmlSerialize(node, context) {
        const result = this.transformGenericNode(node, context);
        return { XmlSerialize: result };
    }
    RuleStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RuleStmt: result };
    }
    RangeSubselect(node, context) {
        const result = this.transformGenericNode(node, context);
        return { RangeSubselect: result };
    }
    SQLValueFunction(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SQLValueFunction: result };
    }
    GroupingFunc(node, context) {
        const result = this.transformGenericNode(node, context);
        return { GroupingFunc: result };
    }
    MultiAssignRef(node, context) {
        const result = this.transformGenericNode(node, context);
        return { MultiAssignRef: result };
    }
    SetToDefault(node, context) {
        const result = this.transformGenericNode(node, context);
        return { SetToDefault: result };
    }
    CurrentOfExpr(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CurrentOfExpr: result };
    }
    TableLikeClause(node, context) {
        const result = this.transformGenericNode(node, context);
        return { TableLikeClause: result };
    }
    AlterFunctionStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterFunctionStmt: result };
    }
    AlterObjectSchemaStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterObjectSchemaStmt: result };
    }
    AlterRoleSetStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { AlterRoleSetStmt: result };
    }
    CreateForeignTableStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateForeignTableStmt: result };
    }
    // NOTE: this doesn't exist in v14?
    CreateAccessMethodStmt(node, context) {
        const result = this.transformGenericNode(node, context);
        return { CreateAccessMethodStmt: result };
    }
}
exports.V14ToV15Transformer = V14ToV15Transformer;
